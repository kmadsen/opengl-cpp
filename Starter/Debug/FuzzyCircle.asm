; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\kmadsen\Google Drive\OpenGL_Projects\Starter\Starter\FuzzyCircle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$0A@@tr1@std@@2IB	; std::tr1::integral_constant<unsigned int,0>::value
PUBLIC	?_Rank@?$_Arithmetic_traits@_N@std@@2HB		; std::_Arithmetic_traits<bool>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@D@std@@2HB		; std::_Arithmetic_traits<char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@C@std@@2HB		; std::_Arithmetic_traits<signed char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@E@std@@2HB		; std::_Arithmetic_traits<unsigned char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@F@std@@2HB		; std::_Arithmetic_traits<short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@G@std@@2HB		; std::_Arithmetic_traits<unsigned short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@H@std@@2HB		; std::_Arithmetic_traits<int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@I@std@@2HB		; std::_Arithmetic_traits<unsigned int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@J@std@@2HB		; std::_Arithmetic_traits<long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@K@std@@2HB		; std::_Arithmetic_traits<unsigned long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_J@std@@2HB		; std::_Arithmetic_traits<__int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_K@std@@2HB		; std::_Arithmetic_traits<unsigned __int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@M@std@@2HB		; std::_Arithmetic_traits<float>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@N@std@@2HB		; std::_Arithmetic_traits<double>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@O@std@@2HB		; std::_Arithmetic_traits<long double>::_Rank
;	COMDAT ?_Rank@?$_Arithmetic_traits@O@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@O@std@@2HB DD 09H		; std::_Arithmetic_traits<long double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@N@std@@2HB DD 08H		; std::_Arithmetic_traits<double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@M@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@M@std@@2HB DD 07H		; std::_Arithmetic_traits<float>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_K@std@@2HB DD 06H		; std::_Arithmetic_traits<unsigned __int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_J@std@@2HB DD 06H		; std::_Arithmetic_traits<__int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@K@std@@2HB DD 05H		; std::_Arithmetic_traits<unsigned long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@J@std@@2HB DD 05H		; std::_Arithmetic_traits<long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@I@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@I@std@@2HB DD 04H		; std::_Arithmetic_traits<unsigned int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@H@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@H@std@@2HB DD 04H		; std::_Arithmetic_traits<int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@G@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@G@std@@2HB DD 03H		; std::_Arithmetic_traits<unsigned short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@F@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@F@std@@2HB DD 03H		; std::_Arithmetic_traits<short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@E@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@E@std@@2HB DD 02H		; std::_Arithmetic_traits<unsigned char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@C@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@C@std@@2HB DD 02H		; std::_Arithmetic_traits<signed char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@D@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@D@std@@2HB DD 02H		; std::_Arithmetic_traits<char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_N@std@@2HB DD 01H		; std::_Arithmetic_traits<bool>::_Rank
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@tr1@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@tr1@std@@2IB DD 00H	; std::tr1::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
PUBLIC	__real@3f4ccccd
PUBLIC	__real@bf4ccccd
PUBLIC	__real@3ee66666
PUBLIC	__real@3e800000
PUBLIC	__real@00000000
PUBLIC	??_C@_0M@KMLIIADO@RadiusOuter?$AA@		; `string'
PUBLIC	??_C@_0M@FCHFHCEL@RadiusInner?$AA@		; `string'
PUBLIC	??_C@_0L@DCMHFHGO@OuterColor?$AA@		; `string'
PUBLIC	??_C@_0L@DMNCCPNN@InnerColor?$AA@		; `string'
PUBLIC	??_C@_0N@ELCNAALI@BlobSettings?$AA@		; `string'
PUBLIC	?LinkShaders@FuzzyCircle@@QAEXHH@Z		; FuzzyCircle::LinkShaders
PUBLIC	??_C@_0CA@LCBMLFIH@Shaders?1basic_uniformblock?4frag?$AA@ ; `string'
PUBLIC	??_C@_0CA@GALNBBJI@Shaders?1basic_uniformblock?4vert?$AA@ ; `string'
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3f800000
PUBLIC	__$ArrayPad$
PUBLIC	?Init@FuzzyCircle@@UAEXXZ			; FuzzyCircle::Init
EXTRN	__imp____glewVertexAttribPointer:DWORD
EXTRN	__imp____glewEnableVertexAttribArray:DWORD
EXTRN	__imp____glewBindVertexArray:DWORD
EXTRN	__imp____glewGenVertexArrays:DWORD
EXTRN	__imp__free:PROC
EXTRN	__imp____glewBindBufferBase:DWORD
EXTRN	__imp____glewBufferData:DWORD
EXTRN	__imp____glewBindBuffer:DWORD
EXTRN	__imp____glewGenBuffers:DWORD
EXTRN	_memcpy:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____glewGetActiveUniformBlockiv:DWORD
EXTRN	__imp____glewGetActiveUniformsiv:DWORD
EXTRN	__imp____glewGetUniformIndices:DWORD
EXTRN	__imp____glewGetUniformBlockIndex:DWORD
EXTRN	?CompileShader@ShaderUtil@@SAIPADI@Z:PROC	; ShaderUtil::CompileShader
EXTRN	__imp__glClearColor@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT __real@3f4ccccd
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\fuzzycircle.cpp
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@bf4ccccd
CONST	SEGMENT
__real@bf4ccccd DD 0bf4ccccdr			; -0.8
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0M@KMLIIADO@RadiusOuter?$AA@
CONST	SEGMENT
??_C@_0M@KMLIIADO@RadiusOuter?$AA@ DB 'RadiusOuter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCHFHCEL@RadiusInner?$AA@
CONST	SEGMENT
??_C@_0M@FCHFHCEL@RadiusInner?$AA@ DB 'RadiusInner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DCMHFHGO@OuterColor?$AA@
CONST	SEGMENT
??_C@_0L@DCMHFHGO@OuterColor?$AA@ DB 'OuterColor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMNCCPNN@InnerColor?$AA@
CONST	SEGMENT
??_C@_0L@DMNCCPNN@InnerColor?$AA@ DB 'InnerColor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ELCNAALI@BlobSettings?$AA@
CONST	SEGMENT
??_C@_0N@ELCNAALI@BlobSettings?$AA@ DB 'BlobSettings', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LCBMLFIH@Shaders?1basic_uniformblock?4frag?$AA@
CONST	SEGMENT
??_C@_0CA@LCBMLFIH@Shaders?1basic_uniformblock?4frag?$AA@ DB 'Shaders/bas'
	DB	'ic_uniformblock.frag', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GALNBBJI@Shaders?1basic_uniformblock?4vert?$AA@
CONST	SEGMENT
??_C@_0CA@GALNBBJI@Shaders?1basic_uniformblock?4vert?$AA@ DB 'Shaders/bas'
	DB	'ic_uniformblock.vert', 00H			; `string'
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ?Init@FuzzyCircle@@UAEXXZ
_TEXT	SEGMENT
_colorBufferHandle$ = -356				; size = 4
_positionBufferHandle$ = -344				; size = 4
_vboHandles$ = -332					; size = 8
_colorData$ = -316					; size = 36
_positionData$ = -272					; size = 36
_uboHandle$ = -228					; size = 4
_outerRadius$ = -216					; size = 4
_innerRadius$ = -204					; size = 4
_innerColor$ = -192					; size = 16
_outerColor$ = -168					; size = 16
_blockBuffer$ = -144					; size = 4
_blockSize$ = -132					; size = 4
_offset$ = -120						; size = 16
_indices$ = -96						; size = 16
_names$ = -72						; size = 16
_blockIndex$ = -48					; size = 4
_fragShader$ = -36					; size = 4
_vertShader$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Init@FuzzyCircle@@UAEXXZ PROC				; FuzzyCircle::Init, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-552]
	mov	ecx, 138				; 0000008aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 18   : 	glClearColor(0.2f,0.2f,0.2f,1.0f);

	mov	esi, esp
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glClearColor@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 19   : 
; 20   : 	// Compile a vertex shader
; 21   : 	GLuint vertShader = ShaderUtil::CompileShader("Shaders/basic_uniformblock.vert", GL_VERTEX_SHADER);

	push	35633					; 00008b31H
	push	OFFSET ??_C@_0CA@GALNBBJI@Shaders?1basic_uniformblock?4vert?$AA@
	call	?CompileShader@ShaderUtil@@SAIPADI@Z	; ShaderUtil::CompileShader
	add	esp, 8
	mov	DWORD PTR _vertShader$[ebp], eax

; 22   : 
; 23   : 	// Compile a fragment shader
; 24   : 	GLuint fragShader = ShaderUtil::CompileShader("Shaders/basic_uniformblock.frag", GL_FRAGMENT_SHADER);

	push	35632					; 00008b30H
	push	OFFSET ??_C@_0CA@LCBMLFIH@Shaders?1basic_uniformblock?4frag?$AA@
	call	?CompileShader@ShaderUtil@@SAIPADI@Z	; ShaderUtil::CompileShader
	add	esp, 8
	mov	DWORD PTR _fragShader$[ebp], eax

; 25   : 
; 26   : 	// Link the shaders
; 27   : 	LinkShaders(vertShader, fragShader);

	mov	eax, DWORD PTR _fragShader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vertShader$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkShaders@FuzzyCircle@@QAEXHH@Z	; FuzzyCircle::LinkShaders

; 28   : 
; 29   : 	// Get blob settings index from the shader
; 30   : 	GLuint blockIndex = glGetUniformBlockIndex(m_ProgramHandle, "BlobSettings");

	mov	esi, esp
	push	OFFSET ??_C@_0N@ELCNAALI@BlobSettings?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __imp____glewGetUniformBlockIndex
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _blockIndex$[ebp], eax

; 31   : 
; 32   : 	// Query for the offset of each variable
; 33   : 	const GLchar* names[] = { "InnerColor", "OuterColor", "RadiusInner", "RadiusOuter" };

	mov	DWORD PTR _names$[ebp], OFFSET ??_C@_0L@DMNCCPNN@InnerColor?$AA@
	mov	DWORD PTR _names$[ebp+4], OFFSET ??_C@_0L@DCMHFHGO@OuterColor?$AA@
	mov	DWORD PTR _names$[ebp+8], OFFSET ??_C@_0M@FCHFHCEL@RadiusInner?$AA@
	mov	DWORD PTR _names$[ebp+12], OFFSET ??_C@_0M@KMLIIADO@RadiusOuter?$AA@

; 34   : 	GLuint indices[4];
; 35   : 	glGetUniformIndices(m_ProgramHandle, 4, names, indices);

	mov	esi, esp
	lea	eax, DWORD PTR _indices$[ebp]
	push	eax
	lea	ecx, DWORD PTR _names$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __imp____glewGetUniformIndices
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 36   : 	GLint offset[4];
; 37   : 	glGetActiveUniformsiv(m_ProgramHandle, 4, indices, GL_UNIFORM_OFFSET, offset);

	mov	esi, esp
	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	push	35387					; 00008a3bH
	lea	ecx, DWORD PTR _indices$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __imp____glewGetActiveUniformsiv
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 38   : 
; 39   : 	// Allocate space for the block data
; 40   : 	GLint blockSize;
; 41   : 	glGetActiveUniformBlockiv(m_ProgramHandle, blockIndex, GL_UNIFORM_BLOCK_DATA_SIZE, &blockSize);

	mov	esi, esp
	lea	eax, DWORD PTR _blockSize$[ebp]
	push	eax
	push	35392					; 00008a40H
	mov	ecx, DWORD PTR _blockIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __imp____glewGetActiveUniformBlockiv
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 42   : 	GLubyte* blockBuffer = (GLubyte*)malloc(blockSize);

	mov	esi, esp
	mov	eax, DWORD PTR _blockSize$[ebp]
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _blockBuffer$[ebp], eax

; 43   : 
; 44   : 	// Put the data into the buffer at the offsets
; 45   : 	GLfloat outerColor[] = { 0.0f, 0.0f, 0.0f, 0.0f };

	fldz
	fstp	DWORD PTR _outerColor$[ebp]
	fldz
	fstp	DWORD PTR _outerColor$[ebp+4]
	fldz
	fstp	DWORD PTR _outerColor$[ebp+8]
	fldz
	fstp	DWORD PTR _outerColor$[ebp+12]

; 46   : 	GLfloat innerColor[] = { 1.0f, 1.0f, 1.0f, 1.0f };

	fld1
	fstp	DWORD PTR _innerColor$[ebp]
	fld1
	fstp	DWORD PTR _innerColor$[ebp+4]
	fld1
	fstp	DWORD PTR _innerColor$[ebp+8]
	fld1
	fstp	DWORD PTR _innerColor$[ebp+12]

; 47   : 	GLfloat innerRadius = 0.25f;

	fld	DWORD PTR __real@3e800000
	fstp	DWORD PTR _innerRadius$[ebp]

; 48   : 	GLfloat outerRadius = 0.45f;

	fld	DWORD PTR __real@3ee66666
	fstp	DWORD PTR _outerRadius$[ebp]

; 49   : 
; 50   : 	memcpy(blockBuffer + offset[0], innerColor, 4*sizeof(GLfloat));

	push	16					; 00000010H
	lea	eax, DWORD PTR _innerColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blockBuffer$[ebp]
	add	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 51   : 	memcpy(blockBuffer + offset[1], outerColor, 4*sizeof(GLfloat));

	push	16					; 00000010H
	lea	eax, DWORD PTR _outerColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blockBuffer$[ebp]
	add	ecx, DWORD PTR _offset$[ebp+4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 52   : 	memcpy(blockBuffer + offset[2], &innerRadius, sizeof(GLfloat));

	push	4
	lea	eax, DWORD PTR _innerRadius$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blockBuffer$[ebp]
	add	ecx, DWORD PTR _offset$[ebp+8]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 53   : 	memcpy(blockBuffer + offset[3], &outerRadius, sizeof(GLfloat));

	push	4
	lea	eax, DWORD PTR _outerRadius$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blockBuffer$[ebp]
	add	ecx, DWORD PTR _offset$[ebp+12]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 54   : 
; 55   : 	// Create the buffer object and copy the data into it
; 56   : 	GLuint uboHandle;
; 57   : 	glGenBuffers(1, &uboHandle);

	mov	esi, esp
	lea	eax, DWORD PTR _uboHandle$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __imp____glewGenBuffers
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 58   : 	glBindBuffer(GL_UNIFORM_BUFFER, uboHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _uboHandle$[ebp]
	push	eax
	push	35345					; 00008a11H
	mov	ecx, DWORD PTR __imp____glewBindBuffer
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 59   : 	glBufferData(GL_UNIFORM_BUFFER, blockSize, blockBuffer, GL_DYNAMIC_DRAW);

	mov	esi, esp
	push	35048					; 000088e8H
	mov	eax, DWORD PTR _blockBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blockSize$[ebp]
	push	ecx
	push	35345					; 00008a11H
	mov	edx, DWORD PTR __imp____glewBufferData
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 60   : 
; 61   : 	// Bind the buffer object to the uniform block
; 62   : 	glBindBufferBase(GL_UNIFORM_BUFFER, blockIndex, uboHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _uboHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blockIndex$[ebp]
	push	ecx
	push	35345					; 00008a11H
	mov	edx, DWORD PTR __imp____glewBindBufferBase
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 63   : 
; 64   : 	free(blockBuffer);

	mov	esi, esp
	mov	eax, DWORD PTR _blockBuffer$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 65   : 	blockBuffer = NULL;

	mov	DWORD PTR _blockBuffer$[ebp], 0

; 66   : 
; 67   : 	/////////////////// Create the VBO ////////////////////
; 68   : 	float positionData[] = {
; 69   : 		-0.8f, -0.8f, 0.0f,

	fld	DWORD PTR __real@bf4ccccd
	fstp	DWORD PTR _positionData$[ebp]
	fld	DWORD PTR __real@bf4ccccd
	fstp	DWORD PTR _positionData$[ebp+4]
	fldz
	fstp	DWORD PTR _positionData$[ebp+8]

; 70   : 		0.8f, -0.8f, 0.0f,

	fld	DWORD PTR __real@3f4ccccd
	fstp	DWORD PTR _positionData$[ebp+12]
	fld	DWORD PTR __real@bf4ccccd
	fstp	DWORD PTR _positionData$[ebp+16]
	fldz
	fstp	DWORD PTR _positionData$[ebp+20]

; 71   : 		0.0f,  0.8f, 0.0f };

	fldz
	fstp	DWORD PTR _positionData$[ebp+24]
	fld	DWORD PTR __real@3f4ccccd
	fstp	DWORD PTR _positionData$[ebp+28]
	fldz
	fstp	DWORD PTR _positionData$[ebp+32]

; 72   : 	float colorData[] = {
; 73   : 		1.0f, 0.0f, 0.0f,

	fld1
	fstp	DWORD PTR _colorData$[ebp]
	fldz
	fstp	DWORD PTR _colorData$[ebp+4]
	fldz
	fstp	DWORD PTR _colorData$[ebp+8]

; 74   : 		0.0f, 1.0f, 0.0f,

	fldz
	fstp	DWORD PTR _colorData$[ebp+12]
	fld1
	fstp	DWORD PTR _colorData$[ebp+16]
	fldz
	fstp	DWORD PTR _colorData$[ebp+20]

; 75   : 		0.0f, 0.0f, 1.0f };

	fldz
	fstp	DWORD PTR _colorData$[ebp+24]
	fldz
	fstp	DWORD PTR _colorData$[ebp+28]
	fld1
	fstp	DWORD PTR _colorData$[ebp+32]

; 76   : 
; 77   : 	// Create and populate the buffer objects
; 78   : 	GLuint vboHandles[2];
; 79   : 	glGenBuffers(2, vboHandles);

	mov	esi, esp
	lea	eax, DWORD PTR _vboHandles$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR __imp____glewGenBuffers
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 80   : 	GLuint positionBufferHandle = vboHandles[0];

	mov	eax, DWORD PTR _vboHandles$[ebp]
	mov	DWORD PTR _positionBufferHandle$[ebp], eax

; 81   : 	GLuint colorBufferHandle = vboHandles[1];

	mov	eax, DWORD PTR _vboHandles$[ebp+4]
	mov	DWORD PTR _colorBufferHandle$[ebp], eax

; 82   : 
; 83   : 	glBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _positionBufferHandle$[ebp]
	push	eax
	push	34962					; 00008892H
	mov	ecx, DWORD PTR __imp____glewBindBuffer
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 84   : 	glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), positionData, GL_STATIC_DRAW);

	mov	esi, esp
	push	35044					; 000088e4H
	lea	eax, DWORD PTR _positionData$[ebp]
	push	eax
	push	36					; 00000024H
	push	34962					; 00008892H
	mov	ecx, DWORD PTR __imp____glewBufferData
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 85   : 
; 86   : 	glBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _colorBufferHandle$[ebp]
	push	eax
	push	34962					; 00008892H
	mov	ecx, DWORD PTR __imp____glewBindBuffer
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 87   : 	glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), colorData, GL_STATIC_DRAW);

	mov	esi, esp
	push	35044					; 000088e4H
	lea	eax, DWORD PTR _colorData$[ebp]
	push	eax
	push	36					; 00000024H
	push	34962					; 00008892H
	mov	ecx, DWORD PTR __imp____glewBufferData
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 88   : 
; 89   : 	// Create and set-up the vertex array object
; 90   : 	glGenVertexArrays(1, &m_VaoHandle );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	esi, esp
	push	eax
	push	1
	mov	ecx, DWORD PTR __imp____glewGenVertexArrays
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 91   : 	glBindVertexArray(m_VaoHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __imp____glewBindVertexArray
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 92   : 
; 93   : 	glEnableVertexAttribArray(0);  // Vertex position

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __imp____glewEnableVertexAttribArray
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 94   : 	glEnableVertexAttribArray(1);  // Vertex color

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR __imp____glewEnableVertexAttribArray
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 95   : 
; 96   : 	glBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _positionBufferHandle$[ebp]
	push	eax
	push	34962					; 00008892H
	mov	ecx, DWORD PTR __imp____glewBindBuffer
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 97   : 	glVertexAttribPointer( 0, 3, GL_FLOAT, GL_TRUE, 0, (GLubyte *)NULL );

	mov	esi, esp
	push	0
	push	0
	push	1
	push	5126					; 00001406H
	push	3
	push	0
	mov	eax, DWORD PTR __imp____glewVertexAttribPointer
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 98   : 
; 99   : 	glBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _colorBufferHandle$[ebp]
	push	eax
	push	34962					; 00008892H
	mov	ecx, DWORD PTR __imp____glewBindBuffer
	mov	edx, DWORD PTR [ecx]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 100  : 	glVertexAttribPointer( 1, 3, GL_FLOAT, GL_TRUE, 0, (GLubyte *)NULL );

	mov	esi, esp
	push	0
	push	0
	push	1
	push	5126					; 00001406H
	push	3
	push	1
	mov	eax, DWORD PTR __imp____glewVertexAttribPointer
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 101  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@Init
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 552				; 00000228H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN16@Init:
	DD	12					; 0000000cH
	DD	$LN15@Init
$LN15@Init:
	DD	-72					; ffffffb8H
	DD	16					; 00000010H
	DD	$LN3@Init
	DD	-96					; ffffffa0H
	DD	16					; 00000010H
	DD	$LN4@Init
	DD	-120					; ffffff88H
	DD	16					; 00000010H
	DD	$LN5@Init
	DD	-132					; ffffff7cH
	DD	4
	DD	$LN6@Init
	DD	-168					; ffffff58H
	DD	16					; 00000010H
	DD	$LN7@Init
	DD	-192					; ffffff40H
	DD	16					; 00000010H
	DD	$LN8@Init
	DD	-204					; ffffff34H
	DD	4
	DD	$LN9@Init
	DD	-216					; ffffff28H
	DD	4
	DD	$LN10@Init
	DD	-228					; ffffff1cH
	DD	4
	DD	$LN11@Init
	DD	-272					; fffffef0H
	DD	36					; 00000024H
	DD	$LN12@Init
	DD	-316					; fffffec4H
	DD	36					; 00000024H
	DD	$LN13@Init
	DD	-332					; fffffeb4H
	DD	8
	DD	$LN14@Init
$LN14@Init:
	DB	118					; 00000076H
	DB	98					; 00000062H
	DB	111					; 0000006fH
	DB	72					; 00000048H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN13@Init:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN12@Init:
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN11@Init:
	DB	117					; 00000075H
	DB	98					; 00000062H
	DB	111					; 0000006fH
	DB	72					; 00000048H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN10@Init:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
$LN9@Init:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
$LN8@Init:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN7@Init:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN6@Init:
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN5@Init:
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN4@Init:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN3@Init:
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
?Init@FuzzyCircle@@UAEXXZ ENDP				; FuzzyCircle::Init
_TEXT	ENDS
PUBLIC	?Render@FuzzyCircle@@UAEXXZ			; FuzzyCircle::Render
EXTRN	__imp__glDrawArrays@12:PROC
EXTRN	__imp__glClear@4:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Render@FuzzyCircle@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Render@FuzzyCircle@@UAEXXZ PROC			; FuzzyCircle::Render, COMDAT
; _this$ = ecx

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 	glClear(GL_COLOR_BUFFER_BIT);

	mov	esi, esp
	push	16384					; 00004000H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 106  : 
; 107  :     glBindVertexArray(m_VaoHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __imp____glewBindVertexArray
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 108  :     glDrawArrays(GL_TRIANGLES, 0, 3 );

	mov	esi, esp
	push	3
	push	0
	push	4
	call	DWORD PTR __imp__glDrawArrays@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 109  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Render@FuzzyCircle@@UAEXXZ ENDP			; FuzzyCircle::Render
_TEXT	ENDS
PUBLIC	??_C@_0BB@KKKBABDI@Program?5log?3?5?6?$CFs?$AA@	; `string'
PUBLIC	??_C@_0CA@FDGLLIKK@Failed?5to?5link?5shader?5program?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@CHIBEAL@Error?5creating?5program?5object?4?6?$AA@ ; `string'
EXTRN	?PrintAttributes@ShaderUtil@@SAXI@Z:PROC	; ShaderUtil::PrintAttributes
EXTRN	__imp____glewUseProgram:DWORD
EXTRN	__imp____glewGetProgramInfoLog:DWORD
EXTRN	__imp____glewGetProgramiv:DWORD
EXTRN	__imp____glewLinkProgram:DWORD
EXTRN	__imp____glewAttachShader:DWORD
EXTRN	__imp__exit:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp____glewCreateProgram:DWORD
;	COMDAT ??_C@_0BB@KKKBABDI@Program?5log?3?5?6?$CFs?$AA@
CONST	SEGMENT
??_C@_0BB@KKKBABDI@Program?5log?3?5?6?$CFs?$AA@ DB 'Program log: ', 0aH, '%'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FDGLLIKK@Failed?5to?5link?5shader?5program?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@FDGLLIKK@Failed?5to?5link?5shader?5program?4?6?$AA@ DB 'Failed '
	DB	'to link shader program.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CHIBEAL@Error?5creating?5program?5object?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@CHIBEAL@Error?5creating?5program?5object?4?6?$AA@ DB 'Error cre'
	DB	'ating program object.', 0aH, 00H		; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?LinkShaders@FuzzyCircle@@QAEXHH@Z
_TEXT	SEGMENT
_written$79763 = -56					; size = 4
_log$79761 = -44					; size = 4
_logLen$79759 = -32					; size = 4
_status$ = -20						; size = 4
_this$ = -8						; size = 4
_vertShader$ = 8					; size = 4
_fragShader$ = 12					; size = 4
?LinkShaders@FuzzyCircle@@QAEXHH@Z PROC			; FuzzyCircle::LinkShaders, COMDAT
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 	// Create the program
; 114  : 	m_ProgramHandle = glCreateProgram();

	mov	eax, DWORD PTR __imp____glewCreateProgram
	mov	esi, esp
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 115  : 	if (m_ProgramHandle == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@LinkShader

; 116  : 		fprintf(stderr, "Error creating program object.\n");

	mov	esi, esp
	push	OFFSET ??_C@_0CA@CHIBEAL@Error?5creating?5program?5object?4?6?$AA@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 117  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@LinkShader:

; 118  : 	}
; 119  : 
; 120  : 	/* Instead of doing this, change basic.vert to have something different */
; 121  : 	//// Bind index 0 to the shader input variable "VertexPosition"
; 122  : 	//glBindAttribLocation(programHandle, 0, "VertexPosition");
; 123  : 	//// Bind index 1 to the shader input variable "VertexColor"
; 124  : 	//glBindAttribLocation(programHandle, 1, "VertexColor");
; 125  : 
; 126  : 	/* This is automatic, so we don't need to do it */
; 127  : 	//glBindFragDataLocation(programHandle, 0, "FragColor");
; 128  : 
; 129  : 	// Attach the shaders to the program object
; 130  : 	glAttachShader(m_ProgramHandle, vertShader);

	mov	esi, esp
	mov	eax, DWORD PTR _vertShader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __imp____glewAttachShader
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 131  : 	glAttachShader(m_ProgramHandle, fragShader);

	mov	esi, esp
	mov	eax, DWORD PTR _fragShader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __imp____glewAttachShader
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 132  : 
; 133  : 	// Link the program
; 134  : 	glLinkProgram(m_ProgramHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __imp____glewLinkProgram
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 135  : 
; 136  : 	// Verify the link status
; 137  : 	GLint status;
; 138  : 	glGetProgramiv(m_ProgramHandle, GL_LINK_STATUS, &status);

	mov	esi, esp
	lea	eax, DWORD PTR _status$[ebp]
	push	eax
	push	35714					; 00008b82H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __imp____glewGetProgramiv
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 139  : 	if (status == GL_FALSE) {

	cmp	DWORD PTR _status$[ebp], 0
	jne	$LN3@LinkShader

; 140  : 		fprintf(stderr, "Failed to link shader program.\n");

	mov	esi, esp
	push	OFFSET ??_C@_0CA@FDGLLIKK@Failed?5to?5link?5shader?5program?4?6?$AA@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 141  : 		GLint logLen;
; 142  : 		glGetProgramiv(m_ProgramHandle, GL_INFO_LOG_LENGTH, &logLen);

	mov	esi, esp
	lea	eax, DWORD PTR _logLen$79759[ebp]
	push	eax
	push	35716					; 00008b84H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __imp____glewGetProgramiv
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 143  : 		if (logLen > 0) {

	cmp	DWORD PTR _logLen$79759[ebp], 0
	jle	$LN2@LinkShader

; 144  : 			char* log = (char*)malloc(logLen);

	mov	esi, esp
	mov	eax, DWORD PTR _logLen$79759[ebp]
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _log$79761[ebp], eax

; 145  : 			GLsizei written;
; 146  : 			glGetProgramInfoLog(m_ProgramHandle, logLen, &written, log);

	mov	esi, esp
	mov	eax, DWORD PTR _log$79761[ebp]
	push	eax
	lea	ecx, DWORD PTR _written$79763[ebp]
	push	ecx
	mov	edx, DWORD PTR _logLen$79759[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __imp____glewGetProgramInfoLog
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 147  : 			fprintf(stderr, "Program log: \n%s", log);

	mov	esi, esp
	mov	eax, DWORD PTR _log$79761[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@KKKBABDI@Program?5log?3?5?6?$CFs?$AA@
	mov	edi, esp
	call	DWORD PTR __imp____iob_func
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 148  : 			free(log);

	mov	esi, esp
	mov	eax, DWORD PTR _log$79761[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@LinkShader:

; 149  : 		}
; 150  : 	}
; 151  : 	else {

	jmp	SHORT $LN1@LinkShader
$LN3@LinkShader:

; 152  : 		// Install the program into the OpenGL pipeline
; 153  : 		glUseProgram(m_ProgramHandle);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __imp____glewUseProgram
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@LinkShader:

; 154  : 	}
; 155  : 
; 156  : 	// Print information about the active attributes in the shader program
; 157  : 	ShaderUtil::PrintAttributes(m_ProgramHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?PrintAttributes@ShaderUtil@@SAXI@Z	; ShaderUtil::PrintAttributes
	add	esp, 4
$LN6@LinkShader:

; 158  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@LinkShader
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN11@LinkShader:
	DD	3
	DD	$LN10@LinkShader
$LN10@LinkShader:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN7@LinkShader
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN8@LinkShader
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN9@LinkShader
$LN9@LinkShader:
	DB	119					; 00000077H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN8@LinkShader:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	103					; 00000067H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN7@LinkShader:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
?LinkShaders@FuzzyCircle@@QAEXHH@Z ENDP			; FuzzyCircle::LinkShaders
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	esi, esp
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
