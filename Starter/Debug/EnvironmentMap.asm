; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\kmadsen\Google Drive\OpenGL_Projects\Starter\Starter\EnvironmentMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$0A@@tr1@std@@2IB	; std::tr1::integral_constant<unsigned int,0>::value
PUBLIC	?_Rank@?$_Arithmetic_traits@_N@std@@2HB		; std::_Arithmetic_traits<bool>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@D@std@@2HB		; std::_Arithmetic_traits<char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@C@std@@2HB		; std::_Arithmetic_traits<signed char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@E@std@@2HB		; std::_Arithmetic_traits<unsigned char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@F@std@@2HB		; std::_Arithmetic_traits<short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@G@std@@2HB		; std::_Arithmetic_traits<unsigned short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@H@std@@2HB		; std::_Arithmetic_traits<int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@I@std@@2HB		; std::_Arithmetic_traits<unsigned int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@J@std@@2HB		; std::_Arithmetic_traits<long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@K@std@@2HB		; std::_Arithmetic_traits<unsigned long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_J@std@@2HB		; std::_Arithmetic_traits<__int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_K@std@@2HB		; std::_Arithmetic_traits<unsigned __int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@M@std@@2HB		; std::_Arithmetic_traits<float>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@N@std@@2HB		; std::_Arithmetic_traits<double>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@O@std@@2HB		; std::_Arithmetic_traits<long double>::_Rank
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@O@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@O@std@@2HB DD 09H		; std::_Arithmetic_traits<long double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@N@std@@2HB DD 08H		; std::_Arithmetic_traits<double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@M@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@M@std@@2HB DD 07H		; std::_Arithmetic_traits<float>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_K@std@@2HB DD 06H		; std::_Arithmetic_traits<unsigned __int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_J@std@@2HB DD 06H		; std::_Arithmetic_traits<__int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@K@std@@2HB DD 05H		; std::_Arithmetic_traits<unsigned long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@J@std@@2HB DD 05H		; std::_Arithmetic_traits<long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@I@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@I@std@@2HB DD 04H		; std::_Arithmetic_traits<unsigned int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@H@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@H@std@@2HB DD 04H		; std::_Arithmetic_traits<int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@G@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@G@std@@2HB DD 03H		; std::_Arithmetic_traits<unsigned short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@F@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@F@std@@2HB DD 03H		; std::_Arithmetic_traits<short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@E@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@E@std@@2HB DD 02H		; std::_Arithmetic_traits<unsigned char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@C@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@C@std@@2HB DD 02H		; std::_Arithmetic_traits<signed char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@D@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@D@std@@2HB DD 02H		; std::_Arithmetic_traits<char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_N@std@@2HB DD 01H		; std::_Arithmetic_traits<bool>::_Rank
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@tr1@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@tr1@std@@2IB DD 00H	; std::tr1::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
PUBLIC	??1GLSLProgram@@QAE@XZ				; GLSLProgram::~GLSLProgram
PUBLIC	__real@3fc00000
PUBLIC	__real@3f333333
PUBLIC	??0?$tmat4x4@M@detail@glm@@QAE@ABM@Z		; glm::detail::tmat4x4<float>::tmat4x4<float>
PUBLIC	__real@3f800000
PUBLIC	??0KRotater@@QAE@XZ				; KRotater::KRotater
PUBLIC	??0KCamera@@QAE@XZ				; KCamera::KCamera
PUBLIC	??0KMouse@@QAE@XZ				; KMouse::KMouse
PUBLIC	??0?$tmat4x4@M@detail@glm@@QAE@XZ		; glm::detail::tmat4x4<float>::tmat4x4<float>
PUBLIC	??_7EnvironmentMap@@6B@				; EnvironmentMap::`vftable'
PUBLIC	??0KScene@@QAE@XZ				; KScene::KScene
PUBLIC	??0EnvironmentMap@@QAE@XZ			; EnvironmentMap::EnvironmentMap
PUBLIC	??_R4EnvironmentMap@@6B@			; EnvironmentMap::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVEnvironmentMap@@@8			; EnvironmentMap `RTTI Type Descriptor'
PUBLIC	??_R3EnvironmentMap@@8				; EnvironmentMap::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2EnvironmentMap@@8				; EnvironmentMap::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@EnvironmentMap@@8			; EnvironmentMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@KScene@@8				; KScene::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVKScene@@@8				; KScene `RTTI Type Descriptor'
PUBLIC	??_R3KScene@@8					; KScene::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2KScene@@8					; KScene::`RTTI Base Class Array'
PUBLIC	?Init@EnvironmentMap@@UAEXXZ			; EnvironmentMap::Init
PUBLIC	?Render@EnvironmentMap@@UAEXXZ			; EnvironmentMap::Render
PUBLIC	?Update@KScene@@UAEXM@Z				; KScene::Update
PUBLIC	?Resize@EnvironmentMap@@UAEXHH@Z		; EnvironmentMap::Resize
PUBLIC	?Mouse@EnvironmentMap@@UAEXABUKMouse@@@Z	; EnvironmentMap::Mouse
PUBLIC	?Motion@EnvironmentMap@@UAEXMM@Z		; EnvironmentMap::Motion
PUBLIC	?Keyboard@EnvironmentMap@@UAEXHMM@Z		; EnvironmentMap::Keyboard
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??0VBOTorus@@QAE@MMHH@Z:PROC			; VBOTorus::VBOTorus
EXTRN	??0VBOTeapot@@QAE@HU?$tmat4x4@M@detail@glm@@@Z:PROC ; VBOTeapot::VBOTeapot
EXTRN	??0SkyBox@@QAE@XZ:PROC				; SkyBox::SkyBox
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??0GLSLProgram@@QAE@XZ:PROC			; GLSLProgram::GLSLProgram
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__fltused:DWORD
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R2KScene@@8
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\environmentmap.cpp
rdata$r	SEGMENT
??_R2KScene@@8 DD FLAT:??_R1A@?0A@EA@KScene@@8		; KScene::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3KScene@@8
rdata$r	SEGMENT
??_R3KScene@@8 DD 00H					; KScene::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2KScene@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVKScene@@@8
_DATA	SEGMENT
??_R0?AVKScene@@@8 DD FLAT:??_7type_info@@6B@		; KScene `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVKScene@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@KScene@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@KScene@@8 DD FLAT:??_R0?AVKScene@@@8	; KScene::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3KScene@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@EnvironmentMap@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@EnvironmentMap@@8 DD FLAT:??_R0?AVEnvironmentMap@@@8 ; EnvironmentMap::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3EnvironmentMap@@8
rdata$r	ENDS
;	COMDAT ??_R2EnvironmentMap@@8
rdata$r	SEGMENT
??_R2EnvironmentMap@@8 DD FLAT:??_R1A@?0A@EA@EnvironmentMap@@8 ; EnvironmentMap::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@KScene@@8
rdata$r	ENDS
;	COMDAT ??_R3EnvironmentMap@@8
rdata$r	SEGMENT
??_R3EnvironmentMap@@8 DD 00H				; EnvironmentMap::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2EnvironmentMap@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVEnvironmentMap@@@8
_DATA	SEGMENT
??_R0?AVEnvironmentMap@@@8 DD FLAT:??_7type_info@@6B@	; EnvironmentMap `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEnvironmentMap@@', 00H
_DATA	ENDS
;	COMDAT ??_R4EnvironmentMap@@6B@
rdata$r	SEGMENT
??_R4EnvironmentMap@@6B@ DD 00H				; EnvironmentMap::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEnvironmentMap@@@8
	DD	FLAT:??_R3EnvironmentMap@@8
rdata$r	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_7EnvironmentMap@@6B@
CONST	SEGMENT
??_7EnvironmentMap@@6B@ DD FLAT:??_R4EnvironmentMap@@6B@ ; EnvironmentMap::`vftable'
	DD	FLAT:?Init@EnvironmentMap@@UAEXXZ
	DD	FLAT:?Render@EnvironmentMap@@UAEXXZ
	DD	FLAT:?Update@KScene@@UAEXM@Z
	DD	FLAT:?Resize@EnvironmentMap@@UAEXHH@Z
	DD	FLAT:?Mouse@EnvironmentMap@@UAEXABUKMouse@@@Z
	DD	FLAT:?Motion@EnvironmentMap@@UAEXMM@Z
	DD	FLAT:?Keyboard@EnvironmentMap@@UAEXHMM@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0EnvironmentMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0EnvironmentMap@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0EnvironmentMap@@QAE@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0EnvironmentMap@@QAE@XZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0EnvironmentMap@@QAE@XZ$3
__ehfuncinfo$??0EnvironmentMap@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0EnvironmentMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ??0EnvironmentMap@@QAE@XZ
_TEXT	SEGMENT
tv164 = -316						; size = 4
tv152 = -316						; size = 4
tv132 = -316						; size = 4
$T70677 = -308						; size = 4
$T70678 = -296						; size = 4
$T70681 = -284						; size = 4
$T70682 = -272						; size = 4
$T70683 = -260						; size = 4
$T70684 = -248						; size = 4
$T70687 = -236						; size = 4
$T70688 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0EnvironmentMap@@QAE@XZ PROC				; EnvironmentMap::EnvironmentMap, COMDAT
; _this$ = ecx

; 16   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0EnvironmentMap@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0KScene@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7EnvironmentMap@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0GLSLProgram@@QAE@XZ			; GLSLProgram::GLSLProgram
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0?$tmat4x4@M@detail@glm@@QAE@XZ	; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0?$tmat4x4@M@detail@glm@@QAE@XZ	; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??0?$tmat4x4@M@detail@glm@@QAE@XZ	; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+240], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	??0KMouse@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	??0KCamera@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	??0KRotater@@QAE@XZ			; KRotater::KRotater

; 17   : 	// initialize the models
; 18   :     m_SkyBox = new SkyBox();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T70678[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T70678[ebp], 0
	je	SHORT $LN3@Environmen
	mov	ecx, DWORD PTR $T70678[ebp]
	call	??0SkyBox@@QAE@XZ			; SkyBox::SkyBox
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN4@Environmen
$LN3@Environmen:
	mov	DWORD PTR tv132[ebp], 0
$LN4@Environmen:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T70677[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T70677[ebp]
	mov	DWORD PTR [ecx+240], edx

; 19   : 	m_Teapot = new VBOTeapot(10, mat4(1.0f));

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T70682[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T70682[ebp], 0
	je	SHORT $LN5@Environmen
	fld1
	fstp	DWORD PTR $T70684[ebp]
	sub	esp, 64					; 00000040H
	mov	ecx, esp
	mov	DWORD PTR $T70683[ebp], esp
	lea	eax, DWORD PTR $T70684[ebp]
	push	eax
	call	??0?$tmat4x4@M@detail@glm@@QAE@ABM@Z	; glm::detail::tmat4x4<float>::tmat4x4<float>
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T70682[ebp]
	call	??0VBOTeapot@@QAE@HU?$tmat4x4@M@detail@glm@@@Z ; VBOTeapot::VBOTeapot
	mov	DWORD PTR tv152[ebp], eax
	jmp	SHORT $LN6@Environmen
$LN5@Environmen:
	mov	DWORD PTR tv152[ebp], 0
$LN6@Environmen:
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR $T70681[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T70681[ebp]
	mov	DWORD PTR [edx+244], eax

; 20   : 	m_Torus = new VBOTorus(1.5f, 0.7f, 100, 100);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T70688[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T70688[ebp], 0
	je	SHORT $LN7@Environmen
	push	100					; 00000064H
	push	100					; 00000064H
	push	ecx
	fld	DWORD PTR __real@3f333333
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3fc00000
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR $T70688[ebp]
	call	??0VBOTorus@@QAE@MMHH@Z			; VBOTorus::VBOTorus
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN8@Environmen
$LN7@Environmen:
	mov	DWORD PTR tv164[ebp], 0
$LN8@Environmen:
	mov	eax, DWORD PTR tv164[ebp]
	mov	DWORD PTR $T70687[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T70687[ebp]
	mov	DWORD PTR [ecx+248], edx

; 21   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0EnvironmentMap@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1GLSLProgram@@QAE@XZ
__unwindfunclet$??0EnvironmentMap@@QAE@XZ$1:
	mov	eax, DWORD PTR $T70678[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0EnvironmentMap@@QAE@XZ$2:
	mov	eax, DWORD PTR $T70682[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0EnvironmentMap@@QAE@XZ$3:
	mov	eax, DWORD PTR $T70688[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0EnvironmentMap@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0EnvironmentMap@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0EnvironmentMap@@QAE@XZ ENDP				; EnvironmentMap::EnvironmentMap
PUBLIC	??4?$tvec2@M@detail@glm@@QAEAAU012@ABU012@@Z	; glm::detail::tvec2<float>::operator=
PUBLIC	??0?$tvec2@M@detail@glm@@QAE@ABM@Z		; glm::detail::tvec2<float>::tvec2<float>
PUBLIC	__real@00000000
PUBLIC	??0?$tvec2@M@detail@glm@@QAE@XZ			; glm::detail::tvec2<float>::tvec2<float>
;	COMDAT __real@00000000
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\kscene.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0KRotater@@QAE@XZ
_TEXT	SEGMENT
$T70724 = -228						; size = 8
$T70725 = -212						; size = 4
_this$ = -8						; size = 4
??0KRotater@@QAE@XZ PROC				; KRotater::KRotater, COMDAT
; _this$ = ecx

; 10   : 	KRotater()

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$tvec2@M@detail@glm@@QAE@XZ		; glm::detail::tvec2<float>::tvec2<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$tmat4x4@M@detail@glm@@QAE@XZ	; glm::detail::tmat4x4<float>::tmat4x4<float>

; 11   : 	{
; 12   : 		m_RotateAngles = glm::vec2(0.0f);

	fldz
	fstp	DWORD PTR $T70725[ebp]
	lea	eax, DWORD PTR $T70725[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70724[ebp]
	call	??0?$tvec2@M@detail@glm@@QAE@ABM@Z	; glm::detail::tvec2<float>::tvec2<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$tvec2@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec2<float>::operator=

; 13   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0KRotater@@QAE@XZ ENDP				; KRotater::KRotater
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?Update@KScene@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_dt$ = 8						; size = 4
?Update@KScene@@UAEXM@Z PROC				; KScene::Update, COMDAT
; _this$ = ecx

; 126  : 	virtual void Update(float dt) { };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Update@KScene@@UAEXM@Z ENDP				; KScene::Update
_TEXT	ENDS
PUBLIC	??_7KScene@@6B@					; KScene::`vftable'
PUBLIC	??_R4KScene@@6B@				; KScene::`RTTI Complete Object Locator'
PUBLIC	?Resize@KScene@@UAEXHH@Z			; KScene::Resize
PUBLIC	?Mouse@KScene@@UAEXABUKMouse@@@Z		; KScene::Mouse
PUBLIC	?Motion@KScene@@UAEXMM@Z			; KScene::Motion
PUBLIC	?Keyboard@KScene@@UAEXHMM@Z			; KScene::Keyboard
EXTRN	__purecall:PROC
;	COMDAT ??_R4KScene@@6B@
rdata$r	SEGMENT
??_R4KScene@@6B@ DD 00H					; KScene::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVKScene@@@8
	DD	FLAT:??_R3KScene@@8
rdata$r	ENDS
;	COMDAT ??_7KScene@@6B@
CONST	SEGMENT
??_7KScene@@6B@ DD FLAT:??_R4KScene@@6B@		; KScene::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Update@KScene@@UAEXM@Z
	DD	FLAT:?Resize@KScene@@UAEXHH@Z
	DD	FLAT:?Mouse@KScene@@UAEXABUKMouse@@@Z
	DD	FLAT:?Motion@KScene@@UAEXMM@Z
	DD	FLAT:?Keyboard@KScene@@UAEXHMM@Z
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0KScene@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0KScene@@QAE@XZ PROC					; KScene::KScene, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7KScene@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0KScene@@QAE@XZ ENDP					; KScene::KScene
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?Resize@KScene@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?Resize@KScene@@UAEXHH@Z PROC				; KScene::Resize, COMDAT
; _this$ = ecx

; 127  : 	virtual void Resize(int width, int height) { };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Resize@KScene@@UAEXHH@Z ENDP				; KScene::Resize
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?Mouse@KScene@@UAEXABUKMouse@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_mouse$ = 8						; size = 4
?Mouse@KScene@@UAEXABUKMouse@@@Z PROC			; KScene::Mouse, COMDAT
; _this$ = ecx

; 128  : 	virtual void Mouse(const KMouse &mouse) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Mouse@KScene@@UAEXABUKMouse@@@Z ENDP			; KScene::Mouse
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?Motion@KScene@@UAEXMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?Motion@KScene@@UAEXMM@Z PROC				; KScene::Motion, COMDAT
; _this$ = ecx

; 129  : 	virtual void Motion(float x, float y) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Motion@KScene@@UAEXMM@Z ENDP				; KScene::Motion
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?Keyboard@KScene@@UAEXHMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?Keyboard@KScene@@UAEXHMM@Z PROC			; KScene::Keyboard, COMDAT
; _this$ = ecx

; 130  : 	virtual void Keyboard(int key, float x, float y) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Keyboard@KScene@@UAEXHMM@Z ENDP			; KScene::Keyboard
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1GLSLProgram@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1GLSLProgram@@QAE@XZ PROC				; GLSLProgram::~GLSLProgram, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1GLSLProgram@@QAE@XZ ENDP				; GLSLProgram::~GLSLProgram
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0KMouse@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0KMouse@@QAE@XZ PROC					; KMouse::KMouse, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$tvec2@M@detail@glm@@QAE@XZ		; glm::detail::tvec2<float>::tvec2<float>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0KMouse@@QAE@XZ ENDP					; KMouse::KMouse
_TEXT	ENDS
PUBLIC	??0?$tvec3@M@detail@glm@@QAE@XZ			; glm::detail::tvec3<float>::tvec3<float>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0KCamera@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0KCamera@@QAE@XZ PROC					; KCamera::KCamera, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@XZ		; glm::detail::tvec3<float>::tvec3<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$tvec3@M@detail@glm@@QAE@XZ		; glm::detail::tvec3<float>::tvec3<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$tvec3@M@detail@glm@@QAE@XZ		; glm::detail::tvec3<float>::tvec3<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$tmat4x4@M@detail@glm@@QAE@XZ	; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0KRotater@@QAE@XZ			; KRotater::KRotater
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0KCamera@@QAE@XZ ENDP					; KCamera::KCamera
_TEXT	ENDS
PUBLIC	??1EnvironmentMap@@QAE@XZ			; EnvironmentMap::~EnvironmentMap
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\environmentmap.cpp
;	COMDAT ??1EnvironmentMap@@QAE@XZ
_TEXT	SEGMENT
$T70749 = -236						; size = 4
$T70750 = -224						; size = 4
$T70751 = -212						; size = 4
_this$ = -8						; size = 4
??1EnvironmentMap@@QAE@XZ PROC				; EnvironmentMap::~EnvironmentMap, COMDAT
; _this$ = ecx

; 24   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7EnvironmentMap@@6B@

; 25   : 	delete m_Torus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+248]
	mov	DWORD PTR $T70749[ebp], ecx
	mov	edx, DWORD PTR $T70749[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 26   : 	delete m_Teapot;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	DWORD PTR $T70750[ebp], ecx
	mov	edx, DWORD PTR $T70750[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 27   : 	delete m_SkyBox;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	mov	DWORD PTR $T70751[ebp], ecx
	mov	edx, DWORD PTR $T70751[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 28   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1GLSLProgram@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1EnvironmentMap@@QAE@XZ ENDP				; EnvironmentMap::~EnvironmentMap
_TEXT	ENDS
PUBLIC	?LoadCubeMap@EnvironmentMap@@AAEXXZ		; EnvironmentMap::LoadCubeMap
PUBLIC	?SetUp@KCamera@@QAEXMMM@Z			; KCamera::SetUp
PUBLIC	__real@bf800000
PUBLIC	?SetCenter@KCamera@@QAEXMMM@Z			; KCamera::SetCenter
PUBLIC	?SetEye@KCamera@@QAEXMMM@Z			; KCamera::SetEye
PUBLIC	__real@c0400000
PUBLIC	__real@41700000
PUBLIC	??_C@_0BD@FDHOOOKA@Material?4Shininess?$AA@	; `string'
PUBLIC	??_C@_0BC@MBBKMINF@Material?4Specular?$AA@	; `string'
PUBLIC	??_C@_0P@GDKHOFPI@Light?4Specular?$AA@		; `string'
PUBLIC	??_C@_0O@KGNIAMLF@Light?4Diffuse?$AA@		; `string'
PUBLIC	__real@3f4ccccd
PUBLIC	??_C@_0O@BEIILHKJ@Light?4Ambient?$AA@		; `string'
PUBLIC	??_C@_0P@LMHDNJPN@Light?4Position?$AA@		; `string'
PUBLIC	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z		; glm::detail::tvec4<float>::tvec4<float>
PUBLIC	__real@40800000
PUBLIC	__real@41200000
PUBLIC	__real@40a00000
PUBLIC	__real@3e4ccccd
PUBLIC	??_C@_0BN@FIEKAHHA@Shaders?1environment_map?4frag?$AA@ ; `string'
PUBLIC	??_C@_0BN@IKOLKDGP@Shaders?1environment_map?4vert?$AA@ ; `string'
EXTRN	?SetUniform@GLSLProgram@@QAEXPBDM@Z:PROC	; GLSLProgram::SetUniform
EXTRN	?SetUniform@GLSLProgram@@QAEXPBDMMM@Z:PROC	; GLSLProgram::SetUniform
EXTRN	?SetUniform@GLSLProgram@@QAEXPBDABU?$tvec4@M@detail@glm@@@Z:PROC ; GLSLProgram::SetUniform
EXTRN	__imp__glEnable@4:PROC
EXTRN	__imp__glClearColor@16:PROC
EXTRN	?Use@GLSLProgram@@QAEXXZ:PROC			; GLSLProgram::Use
EXTRN	?Link@GLSLProgram@@QAE_NXZ:PROC			; GLSLProgram::Link
EXTRN	__imp__exit:PROC
EXTRN	?CompileShaderFromFile@GLSLProgram@@QAE_NPBDW4GLSLShaderType@GLSLShader@@@Z:PROC ; GLSLProgram::CompileShaderFromFile
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@c0400000
CONST	SEGMENT
__real@c0400000 DD 0c0400000r			; -3
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT ??_C@_0BD@FDHOOOKA@Material?4Shininess?$AA@
CONST	SEGMENT
??_C@_0BD@FDHOOOKA@Material?4Shininess?$AA@ DB 'Material.Shininess', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBBKMINF@Material?4Specular?$AA@
CONST	SEGMENT
??_C@_0BC@MBBKMINF@Material?4Specular?$AA@ DB 'Material.Specular', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GDKHOFPI@Light?4Specular?$AA@
CONST	SEGMENT
??_C@_0P@GDKHOFPI@Light?4Specular?$AA@ DB 'Light.Specular', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KGNIAMLF@Light?4Diffuse?$AA@
CONST	SEGMENT
??_C@_0O@KGNIAMLF@Light?4Diffuse?$AA@ DB 'Light.Diffuse', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT ??_C@_0O@BEIILHKJ@Light?4Ambient?$AA@
CONST	SEGMENT
??_C@_0O@BEIILHKJ@Light?4Ambient?$AA@ DB 'Light.Ambient', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMHDNJPN@Light?4Position?$AA@
CONST	SEGMENT
??_C@_0P@LMHDNJPN@Light?4Position?$AA@ DB 'Light.Position', 00H ; `string'
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT ??_C@_0BN@FIEKAHHA@Shaders?1environment_map?4frag?$AA@
CONST	SEGMENT
??_C@_0BN@FIEKAHHA@Shaders?1environment_map?4frag?$AA@ DB 'Shaders/enviro'
	DB	'nment_map.frag', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IKOLKDGP@Shaders?1environment_map?4vert?$AA@
CONST	SEGMENT
??_C@_0BN@IKOLKDGP@Shaders?1environment_map?4vert?$AA@ DB 'Shaders/enviro'
	DB	'nment_map.vert', 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Init@EnvironmentMap@@UAEXXZ
_TEXT	SEGMENT
$T70755 = -272						; size = 16
$T70756 = -248						; size = 4
$T70757 = -236						; size = 4
$T70758 = -224						; size = 4
$T70759 = -212						; size = 4
_this$ = -8						; size = 4
?Init@EnvironmentMap@@UAEXXZ PROC			; EnvironmentMap::Init, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	// Compile and link shaders
; 33   : 	if (!m_Program.CompileShaderFromFile("Shaders/environment_map.vert", GLSLShader::VERTEX)) {

	push	0
	push	OFFSET ??_C@_0BN@IKOLKDGP@Shaders?1environment_map?4vert?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?CompileShaderFromFile@GLSLProgram@@QAE_NPBDW4GLSLShaderType@GLSLShader@@@Z ; GLSLProgram::CompileShaderFromFile
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@Init

; 34   : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Init:

; 35   : 	}
; 36   : 	if (!m_Program.CompileShaderFromFile("Shaders/environment_map.frag", GLSLShader::FRAGMENT)) {

	push	1
	push	OFFSET ??_C@_0BN@FIEKAHHA@Shaders?1environment_map?4frag?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?CompileShaderFromFile@GLSLProgram@@QAE_NPBDW4GLSLShaderType@GLSLShader@@@Z ; GLSLProgram::CompileShaderFromFile
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Init

; 37   : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Init:

; 38   : 	}
; 39   : 	if (!m_Program.Link()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Link@GLSLProgram@@QAE_NXZ		; GLSLProgram::Link
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@Init

; 40   : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Init:

; 41   : 	}
; 42   : 	m_Program.Use();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Use@GLSLProgram@@QAEXXZ		; GLSLProgram::Use

; 43   : 
; 44   : 	// Initialize gl
; 45   : 	glClearColor(0.2f,0.2f,0.2f,1.0f);

	mov	esi, esp
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glClearColor@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 46   : 	glEnable(GL_DEPTH_TEST);

	mov	esi, esp
	push	2929					; 00000b71H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 47   : 
; 48   : 	m_Program.SetUniform("Light.Position", vec4(4.0f,10.0f,5.0f,1.0f));

	fld1
	fstp	DWORD PTR $T70756[ebp]
	fld	DWORD PTR __real@40a00000
	fstp	DWORD PTR $T70757[ebp]
	fld	DWORD PTR __real@41200000
	fstp	DWORD PTR $T70758[ebp]
	fld	DWORD PTR __real@40800000
	fstp	DWORD PTR $T70759[ebp]
	lea	eax, DWORD PTR $T70756[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70757[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70758[ebp]
	push	edx
	lea	eax, DWORD PTR $T70759[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70755[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	push	OFFSET ??_C@_0P@LMHDNJPN@Light?4Position?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDABU?$tvec4@M@detail@glm@@@Z ; GLSLProgram::SetUniform

; 49   : 	m_Program.SetUniform("Light.Ambient", 0.2f, 0.2f, 0.2f);

	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0O@BEIILHKJ@Light?4Ambient?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDMMM@Z	; GLSLProgram::SetUniform

; 50   : 	m_Program.SetUniform("Light.Diffuse", 0.8f, 0.8f, 0.8f);

	push	ecx
	fld	DWORD PTR __real@3f4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f4ccccd
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0O@KGNIAMLF@Light?4Diffuse?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDMMM@Z	; GLSLProgram::SetUniform

; 51   : 	m_Program.SetUniform("Light.Specular", 0.2f, 0.2f, 0.2f);

	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0P@GDKHOFPI@Light?4Specular?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDMMM@Z	; GLSLProgram::SetUniform

; 52   : 
; 53   : 	m_Program.SetUniform("Material.Specular", 1.0f, 1.0f, 1.0f);

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0BC@MBBKMINF@Material?4Specular?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDMMM@Z	; GLSLProgram::SetUniform

; 54   : 	m_Program.SetUniform("Material.Shininess", 1.0f);

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0BD@FDHOOOKA@Material?4Shininess?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDM@Z	; GLSLProgram::SetUniform

; 55   : 
; 56   : 	m_Camera.SetEye(0.0f,-3.0f,15.0f);

	push	ecx
	fld	DWORD PTR __real@41700000
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@c0400000
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?SetEye@KCamera@@QAEXMMM@Z		; KCamera::SetEye

; 57   : 	m_Camera.SetCenter(0.0f,0.0f,0.0f);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?SetCenter@KCamera@@QAEXMMM@Z		; KCamera::SetCenter

; 58   : 	m_Camera.SetUp(0.0f,-1.0f,0.0f);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@bf800000
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?SetUp@KCamera@@QAEXMMM@Z		; KCamera::SetUp

; 59   : 
; 60   : 	LoadCubeMap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadCubeMap@EnvironmentMap@@AAEXXZ	; EnvironmentMap::LoadCubeMap
$LN4@Init:

; 61   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Init@EnvironmentMap@@UAEXXZ ENDP			; EnvironmentMap::Init
_TEXT	ENDS
PUBLIC	?UpdateView@KCamera@@AAEXXZ			; KCamera::UpdateView
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\kscene.h
;	COMDAT ?SetEye@KCamera@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetEye@KCamera@@QAEXMMM@Z PROC				; KCamera::SetEye, COMDAT
; _this$ = ecx

; 45   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 		Eye.x = x; Eye.y = y; Eye.z = z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [eax+8]

; 47   : 		UpdateView();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateView@KCamera@@AAEXXZ		; KCamera::UpdateView

; 48   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetEye@KCamera@@QAEXMMM@Z ENDP				; KCamera::SetEye
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?SetCenter@KCamera@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetCenter@KCamera@@QAEXMMM@Z PROC			; KCamera::SetCenter, COMDAT
; _this$ = ecx

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 52   : 		Center.x = x; Center.y = y; Center.z = z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [eax+20]

; 53   : 		UpdateView();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateView@KCamera@@AAEXXZ		; KCamera::UpdateView

; 54   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetCenter@KCamera@@QAEXMMM@Z ENDP			; KCamera::SetCenter
_TEXT	ENDS
PUBLIC	??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z	; glm::detail::tvec3<float>::operator=
PUBLIC	??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z ; glm::normalize<float>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetUp@KCamera@@QAEXMMM@Z
_TEXT	SEGMENT
$T70782 = -220						; size = 12
_this$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetUp@KCamera@@QAEXMMM@Z PROC				; KCamera::SetUp, COMDAT
; _this$ = ecx

; 57   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 58   : 		Up.x = x; Up.y = y; Up.z = z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+28]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [eax+32]

; 59   : 		Up = glm::normalize(Up);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR $T70782[ebp]
	push	ecx
	call	??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z ; glm::normalize<float>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec3<float>::operator=

; 60   : 		UpdateView();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateView@KCamera@@AAEXXZ		; KCamera::UpdateView

; 61   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetUp@KCamera@@QAEXMMM@Z ENDP				; KCamera::SetUp
_TEXT	ENDS
PUBLIC	??$?DM@detail@glm@@YA?AU?$tmat4x4@M@01@ABU201@0@Z ; glm::detail::operator*<float>
PUBLIC	?GetTransform@KRotater@@QAEABU?$tmat4x4@M@detail@glm@@XZ ; KRotater::GetTransform
PUBLIC	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z	; glm::detail::tmat4x4<float>::operator=
PUBLIC	??$lookAt@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU?$tvec3@M@20@00@Z ; glm::lookAt<float>
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?UpdateView@KCamera@@AAEXXZ
_TEXT	SEGMENT
$T57872 = -348						; size = 64
$T57921 = -276						; size = 64
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?UpdateView@KCamera@@AAEXXZ PROC			; KCamera::UpdateView, COMDAT
; _this$ = ecx

; 90   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-352]
	mov	ecx, 88					; 00000058H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 		View = glm::lookAt(Eye, Center, Up);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR $T57872[ebp]
	push	eax
	call	??$lookAt@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU?$tvec3@M@20@00@Z ; glm::lookAt<float>
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 92   : 		View = Rotater.GetTransform() * View;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?GetTransform@KRotater@@QAEABU?$tmat4x4@M@detail@glm@@XZ ; KRotater::GetTransform
	push	eax
	lea	ecx, DWORD PTR $T57921[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tmat4x4@M@01@ABU201@0@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 93   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateView@KCamera@@AAEXXZ ENDP			; KCamera::UpdateView
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?GetTransform@KRotater@@QAEABU?$tmat4x4@M@detail@glm@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetTransform@KRotater@@QAEABU?$tmat4x4@M@detail@glm@@XZ PROC ; KRotater::GetTransform, COMDAT
; _this$ = ecx

; 33   : 	const glm::mat4 &GetTransform() { return m_Transform; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTransform@KRotater@@QAEABU?$tmat4x4@M@detail@glm@@XZ ENDP ; KRotater::GetTransform
_TEXT	ENDS
PUBLIC	??_C@_0L@HJOMBOJA@Projection?$AA@		; `string'
PUBLIC	??$perspective@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABM000@Z ; glm::perspective<float>
PUBLIC	__real@420c0000
PUBLIC	__real@3dcccccd
PUBLIC	__real@42c80000
PUBLIC	__$ArrayPad$
EXTRN	?SetUniform@GLSLProgram@@QAEXPBDABU?$tmat4x4@M@detail@glm@@@Z:PROC ; GLSLProgram::SetUniform
EXTRN	@_RTC_CheckStackVars@8:PROC
;	COMDAT ??_C@_0L@HJOMBOJA@Projection?$AA@
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\environmentmap.cpp
CONST	SEGMENT
??_C@_0L@HJOMBOJA@Projection?$AA@ DB 'Projection', 00H	; `string'
CONST	ENDS
;	COMDAT __real@420c0000
CONST	SEGMENT
__real@420c0000 DD 0420c0000r			; 35
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Resize@EnvironmentMap@@UAEXHH@Z
_TEXT	SEGMENT
$T70791 = -324						; size = 4
$T70792 = -312						; size = 4
$T70793 = -300						; size = 4
$T62808 = -288						; size = 64
_aspectRatio$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?Resize@EnvironmentMap@@UAEXHH@Z PROC			; EnvironmentMap::Resize, COMDAT
; _this$ = ecx

; 64   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	float aspectRatio = width / (float)height;

	fild	DWORD PTR _width$[ebp]
	fidiv	DWORD PTR _height$[ebp]
	fstp	DWORD PTR _aspectRatio$[ebp]

; 66   : 	m_ProjectionMatrix = perspective(35.0f, aspectRatio, 0.1f, 100.0f);

	fld	DWORD PTR __real@42c80000
	fstp	DWORD PTR $T70791[ebp]
	fld	DWORD PTR __real@3dcccccd
	fstp	DWORD PTR $T70792[ebp]
	fld	DWORD PTR __real@420c0000
	fstp	DWORD PTR $T70793[ebp]
	lea	eax, DWORD PTR $T70791[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70792[ebp]
	push	ecx
	lea	edx, DWORD PTR _aspectRatio$[ebp]
	push	edx
	lea	eax, DWORD PTR $T70793[ebp]
	push	eax
	lea	ecx, DWORD PTR $T62808[ebp]
	push	ecx
	call	??$perspective@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABM000@Z ; glm::perspective<float>
	add	esp, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 67   : 	m_Program.SetUniform("Projection", m_ProjectionMatrix);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	push	OFFSET ??_C@_0L@HJOMBOJA@Projection?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDABU?$tmat4x4@M@detail@glm@@@Z ; GLSLProgram::SetUniform

; 68   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Resize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN5@Resize:
	DD	1
	DD	$LN4@Resize
$LN4@Resize:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Resize
$LN3@Resize:
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	0
?Resize@EnvironmentMap@@UAEXHH@Z ENDP			; EnvironmentMap::Resize
_TEXT	ENDS
PUBLIC	??_C@_03GFEPKPFF@MVP?$AA@			; `string'
PUBLIC	??_C@_0BB@IOMPHHPA@ProjectionMatrix?$AA@	; `string'
PUBLIC	??_C@_0BA@PFLEPDB@ModelViewMatrix?$AA@		; `string'
PUBLIC	??_C@_0M@CLIGNNGK@ModelMatrix?$AA@		; `string'
PUBLIC	??_C@_0N@CINNHGPB@NormalMatrix?$AA@		; `string'
PUBLIC	??0?$tmat3x3@M@detail@glm@@QAE@ABU?$tvec3@M@12@00@Z ; glm::detail::tmat3x3<float>::tmat3x3<float>
PUBLIC	??$?0M@?$tvec3@M@detail@glm@@QAE@ABU?$tvec4@M@12@@Z ; glm::detail::tvec3<float>::tvec3<float><float>
PUBLIC	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
PUBLIC	__$ArrayPad$
PUBLIC	?SetMatrices@EnvironmentMap@@AAEXXZ		; EnvironmentMap::SetMatrices
EXTRN	?SetUniform@GLSLProgram@@QAEXPBDABU?$tmat3x3@M@detail@glm@@@Z:PROC ; GLSLProgram::SetUniform
;	COMDAT ??_C@_03GFEPKPFF@MVP?$AA@
CONST	SEGMENT
??_C@_03GFEPKPFF@MVP?$AA@ DB 'MVP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IOMPHHPA@ProjectionMatrix?$AA@
CONST	SEGMENT
??_C@_0BB@IOMPHHPA@ProjectionMatrix?$AA@ DB 'ProjectionMatrix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PFLEPDB@ModelViewMatrix?$AA@
CONST	SEGMENT
??_C@_0BA@PFLEPDB@ModelViewMatrix?$AA@ DB 'ModelViewMatrix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CLIGNNGK@ModelMatrix?$AA@
CONST	SEGMENT
??_C@_0M@CLIGNNGK@ModelMatrix?$AA@ DB 'ModelMatrix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CINNHGPB@NormalMatrix?$AA@
CONST	SEGMENT
??_C@_0N@CINNHGPB@NormalMatrix?$AA@ DB 'NormalMatrix', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?SetMatrices@EnvironmentMap@@AAEXXZ
_TEXT	SEGMENT
$T70807 = -452						; size = 12
$T70808 = -432						; size = 12
$T70809 = -412						; size = 12
_NormalMatrix$ = -200					; size = 36
_MVP$ = -156						; size = 64
_ModelView$ = -84					; size = 64
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?SetMatrices@EnvironmentMap@@AAEXXZ PROC		; EnvironmentMap::SetMatrices, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 456				; 000001c8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-456]
	mov	ecx, 114				; 00000072H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 	// set up matrices
; 73   : 	mat4 ModelView = m_ViewMatrix * m_ModelMatrix;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	lea	edx, DWORD PTR _ModelView$[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tmat4x4@M@01@ABU201@0@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH

; 74   : 	mat4 MVP = m_ProjectionMatrix * ModelView;

	lea	eax, DWORD PTR _ModelView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	push	ecx
	lea	edx, DWORD PTR _MVP$[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tmat4x4@M@01@ABU201@0@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH

; 75   : 	mat3 NormalMatrix = 
; 76   : 		mat3(vec3(ModelView[0]),
; 77   : 			 vec3(ModelView[1]),
; 78   : 			 vec3(ModelView[2]));

	push	2
	lea	ecx, DWORD PTR _ModelView$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR $T70807[ebp]
	call	??$?0M@?$tvec3@M@detail@glm@@QAE@ABU?$tvec4@M@12@@Z ; glm::detail::tvec3<float>::tvec3<float><float>
	push	eax
	push	1
	lea	ecx, DWORD PTR _ModelView$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR $T70808[ebp]
	call	??$?0M@?$tvec3@M@detail@glm@@QAE@ABU?$tvec4@M@12@@Z ; glm::detail::tvec3<float>::tvec3<float><float>
	push	eax
	push	0
	lea	ecx, DWORD PTR _ModelView$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR $T70809[ebp]
	call	??$?0M@?$tvec3@M@detail@glm@@QAE@ABU?$tvec4@M@12@@Z ; glm::detail::tvec3<float>::tvec3<float><float>
	push	eax
	lea	ecx, DWORD PTR _NormalMatrix$[ebp]
	call	??0?$tmat3x3@M@detail@glm@@QAE@ABU?$tvec3@M@12@00@Z ; glm::detail::tmat3x3<float>::tmat3x3<float>

; 79   : 
; 80   : 	m_Program.SetUniform("NormalMatrix", NormalMatrix);

	lea	eax, DWORD PTR _NormalMatrix$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@CINNHGPB@NormalMatrix?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDABU?$tmat3x3@M@detail@glm@@@Z ; GLSLProgram::SetUniform

; 81   : 	m_Program.SetUniform("ModelMatrix", m_ModelMatrix);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	push	OFFSET ??_C@_0M@CLIGNNGK@ModelMatrix?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDABU?$tmat4x4@M@detail@glm@@@Z ; GLSLProgram::SetUniform

; 82   : 	m_Program.SetUniform("ModelViewMatrix", ModelView);

	lea	eax, DWORD PTR _ModelView$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@PFLEPDB@ModelViewMatrix?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDABU?$tmat4x4@M@detail@glm@@@Z ; GLSLProgram::SetUniform

; 83   : 	m_Program.SetUniform("ProjectionMatrix", m_ProjectionMatrix);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	push	OFFSET ??_C@_0BB@IOMPHHPA@ProjectionMatrix?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDABU?$tmat4x4@M@detail@glm@@@Z ; GLSLProgram::SetUniform

; 84   : 	m_Program.SetUniform("MVP", MVP);

	lea	eax, DWORD PTR _MVP$[ebp]
	push	eax
	push	OFFSET ??_C@_03GFEPKPFF@MVP?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDABU?$tmat4x4@M@detail@glm@@@Z ; GLSLProgram::SetUniform

; 85   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@SetMatrice
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 456				; 000001c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@SetMatrice:
	DD	3
	DD	$LN6@SetMatrice
$LN6@SetMatrice:
	DD	-84					; ffffffacH
	DD	64					; 00000040H
	DD	$LN3@SetMatrice
	DD	-156					; ffffff64H
	DD	64					; 00000040H
	DD	$LN4@SetMatrice
	DD	-200					; ffffff38H
	DD	36					; 00000024H
	DD	$LN5@SetMatrice
$LN5@SetMatrice:
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
$LN4@SetMatrice:
	DB	77					; 0000004dH
	DB	86					; 00000056H
	DB	80					; 00000050H
	DB	0
$LN3@SetMatrice:
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	86					; 00000056H
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	0
?SetMatrices@EnvironmentMap@@AAEXXZ ENDP		; EnvironmentMap::SetMatrices
_TEXT	ENDS
PUBLIC	??_C@_0N@HOMLPNDJ@Material?4Eta?$AA@		; `string'
PUBLIC	__real@3f75c28f
PUBLIC	??$rotate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABMABU?$tvec3@M@20@@Z ; glm::rotate<float>
PUBLIC	__real@42b40000
PUBLIC	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z		; glm::detail::tvec3<float>::tvec3<float>
PUBLIC	__real@40c00000
PUBLIC	??_C@_0BK@JLPPFJAE@Material?4ReflectionFactor?$AA@ ; `string'
PUBLIC	??_C@_0BE@PLAIMNFM@WorldCameraPosition?$AA@	; `string'
PUBLIC	??$translate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABU?$tvec3@M@20@@Z ; glm::translate<float>
PUBLIC	??$?0N@?$tmat4x4@M@detail@glm@@QAE@ABN@Z	; glm::detail::tmat4x4<float>::tmat4x4<float><double>
PUBLIC	?GetEye@KCamera@@QBE?BU?$tvec3@M@detail@glm@@XZ	; KCamera::GetEye
PUBLIC	__real@3ff0000000000000
PUBLIC	?GetView@KCamera@@QBE?AU?$tmat4x4@M@detail@glm@@XZ ; KCamera::GetView
PUBLIC	??_C@_0L@PMGEBNON@DrawSkyBox?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SetUniform@GLSLProgram@@QAEXPBDABU?$tvec3@M@detail@glm@@@Z:PROC ; GLSLProgram::SetUniform
EXTRN	?SetUniform@GLSLProgram@@QAEXPBD_N@Z:PROC	; GLSLProgram::SetUniform
EXTRN	__imp__glDisable@4:PROC
EXTRN	__imp__glClear@4:PROC
;	COMDAT ??_C@_0N@HOMLPNDJ@Material?4Eta?$AA@
CONST	SEGMENT
??_C@_0N@HOMLPNDJ@Material?4Eta?$AA@ DB 'Material.Eta', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f75c28f
CONST	SEGMENT
__real@3f75c28f DD 03f75c28fr			; 0.96
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT ??_C@_0BK@JLPPFJAE@Material?4ReflectionFactor?$AA@
CONST	SEGMENT
??_C@_0BK@JLPPFJAE@Material?4ReflectionFactor?$AA@ DB 'Material.Reflectio'
	DB	'nFactor', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PLAIMNFM@WorldCameraPosition?$AA@
CONST	SEGMENT
??_C@_0BE@PLAIMNFM@WorldCameraPosition?$AA@ DB 'WorldCameraPosition', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0L@PMGEBNON@DrawSkyBox?$AA@
CONST	SEGMENT
??_C@_0L@PMGEBNON@DrawSkyBox?$AA@ DB 'DrawSkyBox', 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Render@EnvironmentMap@@UAEXXZ
_TEXT	SEGMENT
$T70818 = -1028						; size = 12
$T70819 = -1008						; size = 8
$T70820 = -992						; size = 12
$T70821 = -972						; size = 12
$T70822 = -952						; size = 4
$T70823 = -940						; size = 4
$T70824 = -928						; size = 4
$T70825 = -916						; size = 12
$T70826 = -896						; size = 4
$T70827 = -884						; size = 4
$T70828 = -872						; size = 4
$T70829 = -860						; size = 4
$T70830 = -848						; size = 12
$T70831 = -828						; size = 4
$T70832 = -816						; size = 4
$T70833 = -804						; size = 4
$T70834 = -792						; size = 4
$T62900 = -780						; size = 64
$T62901 = -708						; size = 64
$T62912 = -636						; size = 64
$T62931 = -564						; size = 64
$T62936 = -492						; size = 64
$T62942 = -420						; size = 64
$T62944 = -348						; size = 64
$T62950 = -276						; size = 64
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Render@EnvironmentMap@@UAEXXZ PROC			; EnvironmentMap::Render, COMDAT
; _this$ = ecx

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1032				; 00000408H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1032]
	mov	ecx, 258				; 00000102H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 	// Clear the buffers
; 91   : 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 

	mov	esi, esp
	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 92   : 
; 93   : 	/* Render the skybox */
; 94   : 	
; 95   : 	// Disable the depth and make the sky box model folow the camera.
; 96   : 	// This will make the sky box appear infinately far away no matter where
; 97   : 	// the camera moves
; 98   : 	glDisable(GL_DEPTH_TEST);

	mov	esi, esp
	push	2929					; 00000b71H
	call	DWORD PTR __imp__glDisable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 99   : 	m_Program.SetUniform("DrawSkyBox", true);

	push	1
	push	OFFSET ??_C@_0L@PMGEBNON@DrawSkyBox?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBD_N@Z	; GLSLProgram::SetUniform

; 100  : 	
; 101  : 	m_ViewMatrix = m_Camera.GetView();

	lea	eax, DWORD PTR $T62900[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?GetView@KCamera@@QBE?AU?$tmat4x4@M@detail@glm@@XZ ; KCamera::GetView
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 102  : 	
; 103  : 	m_ModelMatrix = glm::translate(mat4(1.0), m_Camera.GetEye());

	fld1
	fstp	QWORD PTR $T70819[ebp]
	lea	eax, DWORD PTR $T70818[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?GetEye@KCamera@@QBE?BU?$tvec3@M@detail@glm@@XZ ; KCamera::GetEye
	push	eax
	lea	ecx, DWORD PTR $T70819[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T62901[ebp]
	call	??$?0N@?$tmat4x4@M@detail@glm@@QAE@ABN@Z ; glm::detail::tmat4x4<float>::tmat4x4<float><double>
	push	eax
	lea	edx, DWORD PTR $T62912[ebp]
	push	edx
	call	??$translate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABU?$tvec3@M@20@@Z ; glm::translate<float>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 104  : 	
; 105  : 	SetMatrices();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMatrices@EnvironmentMap@@AAEXXZ	; EnvironmentMap::SetMatrices

; 106  : 	
; 107  : 	m_SkyBox->render();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 108  : 
; 109  : 
; 110  : 	/* Render the teapot */
; 111  : 
; 112  : 	glEnable(GL_DEPTH_TEST);

	mov	esi, esp
	push	2929					; 00000b71H
	call	DWORD PTR __imp__glEnable@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 113  : 	m_Program.SetUniform("DrawSkyBox", false);

	push	0
	push	OFFSET ??_C@_0L@PMGEBNON@DrawSkyBox?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBD_N@Z	; GLSLProgram::SetUniform

; 114  : 	m_Program.SetUniform("WorldCameraPosition", m_Camera.GetEye());

	lea	eax, DWORD PTR $T70820[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?GetEye@KCamera@@QBE?BU?$tvec3@M@detail@glm@@XZ ; KCamera::GetEye
	push	eax
	push	OFFSET ??_C@_0BE@PLAIMNFM@WorldCameraPosition?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDABU?$tvec3@M@detail@glm@@@Z ; GLSLProgram::SetUniform

; 115  : 	m_Program.SetUniform("Material.ReflectionFactor", 1.0f);

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0BK@JLPPFJAE@Material?4ReflectionFactor?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDM@Z	; GLSLProgram::SetUniform

; 116  : 	
; 117  : 	m_ViewMatrix = m_Camera.GetView();

	lea	eax, DWORD PTR $T62931[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?GetView@KCamera@@QBE?AU?$tmat4x4@M@detail@glm@@XZ ; KCamera::GetView
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 118  : 	m_ViewMatrix = glm::translate(m_ViewMatrix, vec3(6.0f, 1.0f, 0.0f));

	fldz
	fstp	DWORD PTR $T70822[ebp]
	fld1
	fstp	DWORD PTR $T70823[ebp]
	fld	DWORD PTR __real@40c00000
	fstp	DWORD PTR $T70824[ebp]
	lea	eax, DWORD PTR $T70822[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70823[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70824[ebp]
	push	edx
	lea	ecx, DWORD PTR $T70821[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	lea	ecx, DWORD PTR $T62936[ebp]
	push	ecx
	call	??$translate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABU?$tvec3@M@20@@Z ; glm::translate<float>
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 119  : 
; 120  : 	m_ModelMatrix = m_Rotater.GetTransform();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?GetTransform@KRotater@@QAEABU?$tmat4x4@M@detail@glm@@XZ ; KRotater::GetTransform
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 121  : 	m_ModelMatrix = glm::rotate(m_ModelMatrix, 90.0f, vec3(1.0f, 0.0f, 0.0f));

	fldz
	fstp	DWORD PTR $T70826[ebp]
	fldz
	fstp	DWORD PTR $T70827[ebp]
	fld1
	fstp	DWORD PTR $T70828[ebp]
	fld	DWORD PTR __real@42b40000
	fstp	DWORD PTR $T70829[ebp]
	lea	eax, DWORD PTR $T70826[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70827[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70828[ebp]
	push	edx
	lea	ecx, DWORD PTR $T70825[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	push	eax
	lea	eax, DWORD PTR $T70829[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	lea	edx, DWORD PTR $T62942[ebp]
	push	edx
	call	??$rotate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABMABU?$tvec3@M@20@@Z ; glm::rotate<float>
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 122  : 
; 123  : 	SetMatrices();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMatrices@EnvironmentMap@@AAEXXZ	; EnvironmentMap::SetMatrices

; 124  : 	
; 125  : 	m_Teapot->render();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 126  : 
; 127  : 
; 128  : 	/* Render the torus */
; 129  : 
; 130  : 	m_Program.SetUniform("Material.ReflectionFactor", 0.2f);

	push	ecx
	fld	DWORD PTR __real@3e4ccccd
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0BK@JLPPFJAE@Material?4ReflectionFactor?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDM@Z	; GLSLProgram::SetUniform

; 131  : 	m_Program.SetUniform("Material.Eta", 0.96f);

	push	ecx
	fld	DWORD PTR __real@3f75c28f
	fstp	DWORD PTR [esp]
	push	OFFSET ??_C@_0N@HOMLPNDJ@Material?4Eta?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDM@Z	; GLSLProgram::SetUniform

; 132  : 	m_ViewMatrix = m_Camera.GetView();

	lea	eax, DWORD PTR $T62944[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?GetView@KCamera@@QBE?AU?$tmat4x4@M@detail@glm@@XZ ; KCamera::GetView
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 133  : 
; 134  : 	m_ModelMatrix = m_Rotater.GetTransform();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?GetTransform@KRotater@@QAEABU?$tmat4x4@M@detail@glm@@XZ ; KRotater::GetTransform
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 135  : 	m_ModelMatrix = glm::rotate(m_ModelMatrix, 90.0f, vec3(1.0f, 0.0f, 0.0f));

	fldz
	fstp	DWORD PTR $T70831[ebp]
	fldz
	fstp	DWORD PTR $T70832[ebp]
	fld1
	fstp	DWORD PTR $T70833[ebp]
	fld	DWORD PTR __real@42b40000
	fstp	DWORD PTR $T70834[ebp]
	lea	eax, DWORD PTR $T70831[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70832[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70833[ebp]
	push	edx
	lea	ecx, DWORD PTR $T70830[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	push	eax
	lea	eax, DWORD PTR $T70834[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	lea	edx, DWORD PTR $T62950[ebp]
	push	edx
	call	??$rotate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABMABU?$tvec3@M@20@@Z ; glm::rotate<float>
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 136  : 
; 137  : 	SetMatrices();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMatrices@EnvironmentMap@@AAEXXZ	; EnvironmentMap::SetMatrices

; 138  : 	m_Teapot->render();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+244]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, eax
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 139  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1032				; 00000408H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Render@EnvironmentMap@@UAEXXZ ENDP			; EnvironmentMap::Render
_TEXT	ENDS
PUBLIC	??0?$tvec3@M@detail@glm@@QAE@ABU012@@Z		; glm::detail::tvec3<float>::tvec3<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\kscene.h
;	COMDAT ?GetEye@KCamera@@QBE?BU?$tvec3@M@detail@glm@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetEye@KCamera@@QBE?BU?$tvec3@M@detail@glm@@XZ PROC	; KCamera::GetEye, COMDAT
; _this$ = ecx

; 41   : 	const glm::vec3 GetEye() const { return Eye; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec3<float>::tvec3<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetEye@KCamera@@QBE?BU?$tvec3@M@detail@glm@@XZ ENDP	; KCamera::GetEye
_TEXT	ENDS
PUBLIC	??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tmat4x4<float>::tmat4x4<float>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetView@KCamera@@QBE?AU?$tmat4x4@M@detail@glm@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetView@KCamera@@QBE?AU?$tmat4x4@M@detail@glm@@XZ PROC	; KCamera::GetView, COMDAT
; _this$ = ecx

; 64   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 		return View;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 66   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetView@KCamera@@QBE?AU?$tmat4x4@M@detail@glm@@XZ ENDP	; KCamera::GetView
_TEXT	ENDS
PUBLIC	?SetPosition@KMouse@@QAEXMM@Z			; KMouse::SetPosition
PUBLIC	??_C@_0BA@LNIMOOEE@key?5?$CFc?5pressed?6?$AA@	; `string'
PUBLIC	__real@bdcccccd
PUBLIC	?MoveInViewDirection@KCamera@@QAEXM@Z		; KCamera::MoveInViewDirection
EXTRN	__imp__printf:PROC
;	COMDAT ??_C@_0BA@LNIMOOEE@key?5?$CFc?5pressed?6?$AA@
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\environmentmap.cpp
CONST	SEGMENT
??_C@_0BA@LNIMOOEE@key?5?$CFc?5pressed?6?$AA@ DB 'key %c pressed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@bdcccccd
CONST	SEGMENT
__real@bdcccccd DD 0bdcccccdr			; -0.1
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Keyboard@EnvironmentMap@@UAEXHMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?Keyboard@EnvironmentMap@@UAEXHMM@Z PROC		; EnvironmentMap::Keyboard, COMDAT
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 	if (key == 'w') {

	cmp	DWORD PTR _key$[ebp], 119		; 00000077H
	jne	SHORT $LN3@Keyboard

; 144  : 		m_Camera.MoveInViewDirection(0.1f);

	push	ecx
	fld	DWORD PTR __real@3dcccccd
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?MoveInViewDirection@KCamera@@QAEXM@Z	; KCamera::MoveInViewDirection
	jmp	SHORT $LN1@Keyboard
$LN3@Keyboard:

; 145  : 	}
; 146  : 	else if (key == 's') {

	cmp	DWORD PTR _key$[ebp], 115		; 00000073H
	jne	SHORT $LN1@Keyboard

; 147  : 		m_Camera.MoveInViewDirection(-0.1f);

	push	ecx
	fld	DWORD PTR __real@bdcccccd
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?MoveInViewDirection@KCamera@@QAEXM@Z	; KCamera::MoveInViewDirection
$LN1@Keyboard:

; 148  : 	}
; 149  : 
; 150  : 	printf("key %c pressed\n", key);

	mov	esi, esp
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@LNIMOOEE@key?5?$CFc?5pressed?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 151  : 	m_Mouse.SetPosition(x, y);

	push	ecx
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	?SetPosition@KMouse@@QAEXMM@Z		; KMouse::SetPosition

; 152  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Keyboard@EnvironmentMap@@UAEXHMM@Z ENDP		; EnvironmentMap::Keyboard
_TEXT	ENDS
PUBLIC	??$?YM@?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec3<float>::operator+=<float>
PUBLIC	??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
PUBLIC	??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@0@Z	; glm::detail::operator-<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\kscene.h
;	COMDAT ?MoveInViewDirection@KCamera@@QAEXM@Z
_TEXT	SEGMENT
$T70853 = -260						; size = 12
$T70854 = -240						; size = 12
_vDir$ = -28						; size = 12
_this$ = -8						; size = 4
_delta$ = 8						; size = 4
?MoveInViewDirection@KCamera@@QAEXM@Z PROC		; KCamera::MoveInViewDirection, COMDAT
; _this$ = ecx

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 		glm::vec3 vDir = glm::normalize(Center - Eye) * delta;

	lea	eax, DWORD PTR _delta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	lea	eax, DWORD PTR $T70853[ebp]
	push	eax
	call	??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@0@Z ; glm::detail::operator-<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T70854[ebp]
	push	ecx
	call	??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z ; glm::normalize<float>
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _vDir$[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH

; 71   : 		Center += vDir;

	lea	eax, DWORD PTR _vDir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?YM@?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec3<float>::operator+=<float>

; 72   : 		Eye += vDir;

	lea	eax, DWORD PTR _vDir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?YM@?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec3<float>::operator+=<float>

; 73   : 		UpdateView();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateView@KCamera@@AAEXXZ		; KCamera::UpdateView

; 74   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@MoveInView
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@MoveInView:
	DD	1
	DD	$LN4@MoveInView
$LN4@MoveInView:
	DD	-28					; ffffffe4H
	DD	12					; 0000000cH
	DD	$LN3@MoveInView
$LN3@MoveInView:
	DB	118					; 00000076H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	0
?MoveInViewDirection@KCamera@@QAEXM@Z ENDP		; KCamera::MoveInViewDirection
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?SetPosition@KMouse@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetPosition@KMouse@@QAEXMM@Z PROC			; KMouse::SetPosition, COMDAT
; _this$ = ecx

; 111  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		Position.x = x; Position.y = y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+12]

; 113  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetPosition@KMouse@@QAEXMM@Z ENDP			; KMouse::SetPosition
_TEXT	ENDS
PUBLIC	?Idle@EnvironmentMap@@QAEXXZ			; EnvironmentMap::Idle
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\environmentmap.cpp
;	COMDAT ?Idle@EnvironmentMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Idle@EnvironmentMap@@QAEXXZ PROC			; EnvironmentMap::Idle, COMDAT
; _this$ = ecx

; 155  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 	//m_Rotater.Rotate(vec2(0.0001f, 0.0f));
; 157  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Idle@EnvironmentMap@@QAEXXZ ENDP			; EnvironmentMap::Idle
_TEXT	ENDS
PUBLIC	??4KMouse@@QAEAAU0@ABU0@@Z			; KMouse::operator=
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Mouse@EnvironmentMap@@UAEXABUKMouse@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_mouse$ = 8						; size = 4
?Mouse@EnvironmentMap@@UAEXABUKMouse@@@Z PROC		; EnvironmentMap::Mouse, COMDAT
; _this$ = ecx

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 	// Copy the mouse data over
; 162  : 	m_Mouse = mouse;

	mov	eax, DWORD PTR _mouse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	??4KMouse@@QAEAAU0@ABU0@@Z

; 163  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Mouse@EnvironmentMap@@UAEXABUKMouse@@@Z ENDP		; EnvironmentMap::Mouse
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??4KMouse@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4KMouse@@QAEAAU0@ABU0@@Z PROC				; KMouse::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$tvec2@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec2<float>::operator=
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4KMouse@@QAEAAU0@ABU0@@Z ENDP				; KMouse::operator=
_TEXT	ENDS
PUBLIC	?Rotate@KRotater@@QAEXABU?$tvec2@M@detail@glm@@@Z ; KRotater::Rotate
PUBLIC	?Rotate@KCamera@@QAEXABU?$tvec2@M@detail@glm@@@Z ; KCamera::Rotate
PUBLIC	??$?GM@detail@glm@@YA?AU?$tvec2@M@01@ABU201@0@Z	; glm::detail::operator-<float>
PUBLIC	??0?$tvec2@M@detail@glm@@QAE@ABM0@Z		; glm::detail::tvec2<float>::tvec2<float>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Motion@EnvironmentMap@@UAEXMM@Z
_TEXT	SEGMENT
_delta$ = -40						; size = 8
_newPosition$ = -24					; size = 8
_this$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?Motion@EnvironmentMap@@UAEXMM@Z PROC			; EnvironmentMap::Motion, COMDAT
; _this$ = ecx

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 	vec2 newPosition = vec2(x, y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _newPosition$[ebp]
	call	??0?$tvec2@M@detail@glm@@QAE@ABM0@Z	; glm::detail::tvec2<float>::tvec2<float>

; 168  : 	vec2 delta = newPosition - m_Mouse.Position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	lea	ecx, DWORD PTR _newPosition$[ebp]
	push	ecx
	lea	edx, DWORD PTR _delta$[ebp]
	push	edx
	call	??$?GM@detail@glm@@YA?AU?$tvec2@M@01@ABU201@0@Z ; glm::detail::operator-<float>
	add	esp, 12					; 0000000cH

; 169  : 	m_Mouse.SetPosition(x, y);

	push	ecx
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	?SetPosition@KMouse@@QAEXMM@Z		; KMouse::SetPosition

; 170  : 	if (m_Mouse.Button == KMouse::LEFT) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+252], 0
	jne	SHORT $LN3@Motion

; 171  : 		m_Camera.Rotate(delta);

	lea	eax, DWORD PTR _delta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	call	?Rotate@KCamera@@QAEXABU?$tvec2@M@detail@glm@@@Z ; KCamera::Rotate
	jmp	SHORT $LN1@Motion
$LN3@Motion:

; 172  : 	}
; 173  : 	else if (m_Mouse.Button == KMouse::RIGHT) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+252], 2
	jne	SHORT $LN1@Motion

; 174  : 		m_Rotater.Rotate(delta);

	lea	eax, DWORD PTR _delta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	call	?Rotate@KRotater@@QAEXABU?$tvec2@M@detail@glm@@@Z ; KRotater::Rotate
$LN1@Motion:

; 175  : 	}
; 176  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@Motion
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN9@Motion:
	DD	2
	DD	$LN8@Motion
$LN8@Motion:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN6@Motion
	DD	-40					; ffffffd8H
	DD	8
	DD	$LN7@Motion
$LN7@Motion:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN6@Motion:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?Motion@EnvironmentMap@@UAEXMM@Z ENDP			; EnvironmentMap::Motion
_TEXT	ENDS
PUBLIC	__real@43b40000
PUBLIC	__real@0000000000000000
PUBLIC	__real@4076800000000000
PUBLIC	__real@404ca5dc1a63c1f8
PUBLIC	__$ArrayPad$
;	COMDAT __real@43b40000
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\kscene.h
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@404ca5dc1a63c1f8
CONST	SEGMENT
__real@404ca5dc1a63c1f8 DQ 0404ca5dc1a63c1f8r	; 57.2958
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Rotate@KRotater@@QAEXABU?$tvec2@M@detail@glm@@@Z
_TEXT	SEGMENT
tv171 = -556						; size = 4
tv164 = -556						; size = 4
$T70875 = -548						; size = 8
$T70876 = -532						; size = 12
$T70877 = -512						; size = 4
$T70878 = -500						; size = 4
$T70879 = -488						; size = 4
$T70880 = -476						; size = 12
$T70881 = -456						; size = 4
$T70882 = -444						; size = 4
$T70883 = -432						; size = 4
$T57717 = -420						; size = 64
$T57739 = -348						; size = 64
$T57744 = -276						; size = 64
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_delta$ = 8						; size = 4
?Rotate@KRotater@@QAEXABU?$tvec2@M@detail@glm@@@Z PROC	; KRotater::Rotate, COMDAT
; _this$ = ecx

; 16   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-556]
	mov	ecx, 139				; 0000008bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 17   : 		m_RotateAngles.x -= static_cast<float>(TO_DEGREES(delta.x));

	mov	eax, DWORD PTR _delta$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@404ca5dc1a63c1f8
	fstp	DWORD PTR tv164[ebp]
	fld	DWORD PTR tv164[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 18   : 		m_RotateAngles.y -= static_cast<float>(TO_DEGREES(delta.y));

	mov	eax, DWORD PTR _delta$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@404ca5dc1a63c1f8
	fstp	DWORD PTR tv171[ebp]
	fld	DWORD PTR tv171[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 19   : 		if (m_RotateAngles.x > 360.0f)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@4076800000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@Rotate

; 20   : 			m_RotateAngles.x = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax]
$LN4@Rotate:

; 21   : 		if (m_RotateAngles.x < 0.0f)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@Rotate

; 22   : 			m_RotateAngles.x = 360.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@43b40000
	fstp	DWORD PTR [eax]
$LN3@Rotate:

; 23   : 		if (m_RotateAngles.y > 360.0f)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@4076800000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@Rotate

; 24   : 			m_RotateAngles.y = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+4]
$LN2@Rotate:

; 25   : 		if (m_RotateAngles.y < 0.0f)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@Rotate

; 26   : 			m_RotateAngles.y = 360.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __real@43b40000
	fstp	DWORD PTR [eax+4]
$LN1@Rotate:

; 27   : 
; 28   : 		m_Transform = glm::mat4(1.0);

	fld1
	fstp	QWORD PTR $T70875[ebp]
	lea	eax, DWORD PTR $T70875[ebp]
	push	eax
	lea	ecx, DWORD PTR $T57717[ebp]
	call	??$?0N@?$tmat4x4@M@detail@glm@@QAE@ABN@Z ; glm::detail::tmat4x4<float>::tmat4x4<float><double>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 29   : 		m_Transform = glm::rotate(m_Transform, m_RotateAngles.y, glm::vec3(1.0f, 0.0f, 0.0f));

	fldz
	fstp	DWORD PTR $T70877[ebp]
	fldz
	fstp	DWORD PTR $T70878[ebp]
	fld1
	fstp	DWORD PTR $T70879[ebp]
	lea	eax, DWORD PTR $T70877[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70878[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70879[ebp]
	push	edx
	lea	ecx, DWORD PTR $T70876[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR $T57739[ebp]
	push	edx
	call	??$rotate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABMABU?$tvec3@M@20@@Z ; glm::rotate<float>
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 30   : 		m_Transform = glm::rotate(m_Transform, m_RotateAngles.x, glm::vec3(0.0f, 1.0f, 0.0f));

	fldz
	fstp	DWORD PTR $T70881[ebp]
	fld1
	fstp	DWORD PTR $T70882[ebp]
	fldz
	fstp	DWORD PTR $T70883[ebp]
	lea	eax, DWORD PTR $T70881[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70882[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70883[ebp]
	push	edx
	lea	ecx, DWORD PTR $T70880[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR $T57744[ebp]
	push	edx
	call	??$rotate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABMABU?$tvec3@M@20@@Z ; glm::rotate<float>
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tmat4x4<float>::operator=

; 31   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 556				; 0000022cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Rotate@KRotater@@QAEXABU?$tvec2@M@detail@glm@@@Z ENDP	; KRotater::Rotate
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?Rotate@KCamera@@QAEXABU?$tvec2@M@detail@glm@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_delta$ = 8						; size = 4
?Rotate@KCamera@@QAEXABU?$tvec2@M@detail@glm@@@Z PROC	; KCamera::Rotate, COMDAT
; _this$ = ecx

; 77   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 		Rotater.Rotate(delta);

	mov	eax, DWORD PTR _delta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?Rotate@KRotater@@QAEXABU?$tvec2@M@detail@glm@@@Z ; KRotater::Rotate

; 79   : 		UpdateView();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateView@KCamera@@AAEXXZ		; KCamera::UpdateView

; 80   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Rotate@KCamera@@QAEXABU?$tvec2@M@detail@glm@@@Z ENDP	; KCamera::Rotate
_TEXT	ENDS
PUBLIC	?GetBitMap@EnvironmentMap@@ABEPAUFIBITMAP@@QBD@Z ; EnvironmentMap::GetBitMap
EXTRN	__imp__FreeImage_Unload@4:PROC
EXTRN	__imp__FreeImage_ConvertTo32Bits@4:PROC
EXTRN	__imp__FreeImage_Load@12:PROC
EXTRN	__imp__FreeImage_GetFileType@8:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\kmadsen\google drive\opengl_projects\starter\starter\environmentmap.cpp
;	COMDAT ?GetBitMap@EnvironmentMap@@ABEPAUFIBITMAP@@QBD@Z
_TEXT	SEGMENT
_temp$ = -32						; size = 4
_imageBitmap$ = -20					; size = 4
_this$ = -8						; size = 4
_filename$ = 8						; size = 4
?GetBitMap@EnvironmentMap@@ABEPAUFIBITMAP@@QBD@Z PROC	; EnvironmentMap::GetBitMap, COMDAT
; _this$ = ecx

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 	FIBITMAP* imageBitmap = FreeImage_Load(FreeImage_GetFileType(filename,0), filename);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	edi, esp
	push	0
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	DWORD PTR __imp__FreeImage_GetFileType@8
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	DWORD PTR __imp__FreeImage_Load@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _imageBitmap$[ebp], eax

; 181  : 	FIBITMAP* temp = imageBitmap;

	mov	eax, DWORD PTR _imageBitmap$[ebp]
	mov	DWORD PTR _temp$[ebp], eax

; 182  : 	imageBitmap = FreeImage_ConvertTo32Bits(imageBitmap);

	mov	esi, esp
	mov	eax, DWORD PTR _imageBitmap$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeImage_ConvertTo32Bits@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _imageBitmap$[ebp], eax

; 183  : 	FreeImage_Unload(temp);

	mov	esi, esp
	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeImage_Unload@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 184  : 
; 185  : 	return imageBitmap;

	mov	eax, DWORD PTR _imageBitmap$[ebp]

; 186  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetBitMap@EnvironmentMap@@ABEPAUFIBITMAP@@QBD@Z ENDP	; EnvironmentMap::GetBitMap
_TEXT	ENDS
PUBLIC	??_C@_0L@NDBPDCJF@CubeMapTex?$AA@		; `string'
PUBLIC	__real@47012f00
PUBLIC	__real@46180400
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_C@_04ILGPIKCG@negz?$AA@			; `string'
PUBLIC	??_C@_04CACNEIAN@posz?$AA@			; `string'
PUBLIC	??_C@_04LAABLMO@posy?$AA@			; `string'
PUBLIC	??_C@_04KAECNJOF@negy?$AA@			; `string'
PUBLIC	??_C@_04LJFJOIKE@negx?$AA@			; `string'
PUBLIC	??_C@_04BCBLCKIP@posx?$AA@			; `string'
PUBLIC	??_C@_04GNPKBLNA@?4jpg?$AA@			; `string'
PUBLIC	??_C@_0BH@GFEFGDI@textures?1cubemap_snow?1?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SetUniform@GLSLProgram@@QAEXPBDH@Z:PROC	; GLSLProgram::SetUniform
EXTRN	__imp__glTexParameterf@12:PROC
EXTRN	__imp__glTexImage2D@36:PROC
EXTRN	__imp__FreeImage_GetWidth@4:PROC
EXTRN	__imp__FreeImage_GetHeight@4:PROC
EXTRN	__imp__FreeImage_GetBits@4:PROC
EXTRN	__imp__glBindTexture@8:PROC
EXTRN	__imp__glGenTextures@8:PROC
EXTRN	__imp____glewActiveTexture:DWORD
;	COMDAT ??_C@_0L@NDBPDCJF@CubeMapTex?$AA@
CONST	SEGMENT
??_C@_0L@NDBPDCJF@CubeMapTex?$AA@ DB 'CubeMapTex', 00H	; `string'
CONST	ENDS
;	COMDAT __real@47012f00
CONST	SEGMENT
__real@47012f00 DD 047012f00r			; 33071
CONST	ENDS
;	COMDAT __real@46180400
CONST	SEGMENT
__real@46180400 DD 046180400r			; 9729
CONST	ENDS
;	COMDAT ??_C@_04ILGPIKCG@negz?$AA@
CONST	SEGMENT
??_C@_04ILGPIKCG@negz?$AA@ DB 'negz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CACNEIAN@posz?$AA@
CONST	SEGMENT
??_C@_04CACNEIAN@posz?$AA@ DB 'posz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LAABLMO@posy?$AA@
CONST	SEGMENT
??_C@_04LAABLMO@posy?$AA@ DB 'posy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KAECNJOF@negy?$AA@
CONST	SEGMENT
??_C@_04KAECNJOF@negy?$AA@ DB 'negy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJFJOIKE@negx?$AA@
CONST	SEGMENT
??_C@_04LJFJOIKE@negx?$AA@ DB 'negx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BCBLCKIP@posx?$AA@
CONST	SEGMENT
??_C@_04BCBLCKIP@posx?$AA@ DB 'posx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GNPKBLNA@?4jpg?$AA@
CONST	SEGMENT
??_C@_04GNPKBLNA@?4jpg?$AA@ DB '.jpg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GFEFGDI@textures?1cubemap_snow?1?$AA@
CONST	SEGMENT
??_C@_0BH@GFEFGDI@textures?1cubemap_snow?1?$AA@ DB 'textures/cubemap_snow'
	DB	'/', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadCubeMap@EnvironmentMap@@AAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?LoadCubeMap@EnvironmentMap@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadCubeMap@EnvironmentMap@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadCubeMap@EnvironmentMap@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadCubeMap@EnvironmentMap@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadCubeMap@EnvironmentMap@@AAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadCubeMap@EnvironmentMap@@AAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadCubeMap@EnvironmentMap@@AAEXXZ$2
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?LoadCubeMap@EnvironmentMap@@AAEXXZ
_TEXT	SEGMENT
tv197 = -480						; size = 4
tv200 = -476						; size = 4
tv195 = -472						; size = 4
tv199 = -468						; size = 4
$T63018 = -460						; size = 32
$T63045 = -420						; size = 32
_imageBitmap$63047 = -188				; size = 4
_texName$63017 = -176					; size = 32
_i$63013 = -136						; size = 4
_targets$ = -124					; size = 24
_suffixes$ = -92					; size = 24
_extension$ = -60					; size = 4
_baseFileName$ = -48					; size = 4
_tid$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LoadCubeMap@EnvironmentMap@@AAEXXZ PROC		; EnvironmentMap::LoadCubeMap, COMDAT
; _this$ = ecx

; 189  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadCubeMap@EnvironmentMap@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-480]
	mov	ecx, 117				; 00000075H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 	glActiveTexture(GL_TEXTURE0);

	mov	esi, esp
	push	33984					; 000084c0H
	mov	eax, DWORD PTR __imp____glewActiveTexture
	mov	ecx, DWORD PTR [eax]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 191  : 
; 192  : 	GLuint tid;
; 193  : 	glGenTextures(1, &tid);

	mov	esi, esp
	lea	eax, DWORD PTR _tid$[ebp]
	push	eax
	push	1
	call	DWORD PTR __imp__glGenTextures@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 194  : 	glBindTexture(GL_TEXTURE_CUBE_MAP, tid);

	mov	esi, esp
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	push	34067					; 00008513H
	call	DWORD PTR __imp__glBindTexture@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 195  : 
; 196  : 	//const char* baseFileName = "Textures/cubemap_panorama/";
; 197  : 	//const char* extension = ".png";
; 198  : 	const char* baseFileName = "textures/cubemap_snow/";

	mov	DWORD PTR _baseFileName$[ebp], OFFSET ??_C@_0BH@GFEFGDI@textures?1cubemap_snow?1?$AA@

; 199  : 	const char* extension = ".jpg";

	mov	DWORD PTR _extension$[ebp], OFFSET ??_C@_04GNPKBLNA@?4jpg?$AA@

; 200  : 	const char* suffixes[] =  {
; 201  : 		"posx", "negx", 

	mov	DWORD PTR _suffixes$[ebp], OFFSET ??_C@_04BCBLCKIP@posx?$AA@
	mov	DWORD PTR _suffixes$[ebp+4], OFFSET ??_C@_04LJFJOIKE@negx?$AA@

; 202  : 		"negy", "posy", 

	mov	DWORD PTR _suffixes$[ebp+8], OFFSET ??_C@_04KAECNJOF@negy?$AA@
	mov	DWORD PTR _suffixes$[ebp+12], OFFSET ??_C@_04LAABLMO@posy?$AA@

; 203  : 		"posz", "negz"

	mov	DWORD PTR _suffixes$[ebp+16], OFFSET ??_C@_04CACNEIAN@posz?$AA@

; 204  : 	};

	mov	DWORD PTR _suffixes$[ebp+20], OFFSET ??_C@_04ILGPIKCG@negz?$AA@

; 205  : 
; 206  : 	GLuint targets[] = {
; 207  : 		GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,

	mov	DWORD PTR _targets$[ebp], 34069		; 00008515H
	mov	DWORD PTR _targets$[ebp+4], 34070	; 00008516H

; 208  : 		GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,

	mov	DWORD PTR _targets$[ebp+8], 34071	; 00008517H
	mov	DWORD PTR _targets$[ebp+12], 34072	; 00008518H

; 209  : 		GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z

	mov	DWORD PTR _targets$[ebp+16], 34073	; 00008519H

; 210  : 	};

	mov	DWORD PTR _targets$[ebp+20], 34074	; 0000851aH

; 211  : 
; 212  : 	for (int i = 0; i < 6; i++) {

	mov	DWORD PTR _i$63013[ebp], 0
	jmp	SHORT $LN3@LoadCubeMa
$LN2@LoadCubeMa:
	mov	eax, DWORD PTR _i$63013[ebp]
	add	eax, 1
	mov	DWORD PTR _i$63013[ebp], eax
$LN3@LoadCubeMa:
	cmp	DWORD PTR _i$63013[ebp], 6
	jge	$LN1@LoadCubeMa

; 213  : 		string texName = string(baseFileName) + suffixes[i] + extension;

	mov	eax, DWORD PTR _extension$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$63013[ebp]
	mov	edx, DWORD PTR _suffixes$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _baseFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T63018[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv199[ebp], eax
	mov	ecx, DWORD PTR tv199[ebp]
	mov	DWORD PTR tv195[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv195[ebp]
	push	edx
	lea	eax, DWORD PTR $T63045[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv200[ebp], eax
	mov	ecx, DWORD PTR tv200[ebp]
	mov	DWORD PTR tv197[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv197[ebp]
	push	edx
	lea	eax, DWORD PTR _texName$63017[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T63045[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T63018[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 214  : 		FIBITMAP* imageBitmap = GetBitMap(texName.c_str());

	lea	ecx, DWORD PTR _texName$63017[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBitMap@EnvironmentMap@@ABEPAUFIBITMAP@@QBD@Z ; EnvironmentMap::GetBitMap
	mov	DWORD PTR _imageBitmap$63047[ebp], eax

; 215  : 		glTexImage2D(targets[i], 0, GL_RGBA, 
; 216  : 			FreeImage_GetWidth(imageBitmap), FreeImage_GetHeight(imageBitmap), 
; 217  : 			0, GL_BGRA, GL_UNSIGNED_BYTE, FreeImage_GetBits(imageBitmap));

	mov	esi, esp
	mov	eax, DWORD PTR _imageBitmap$63047[ebp]
	push	eax
	call	DWORD PTR __imp__FreeImage_GetBits@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	push	5121					; 00001401H
	push	32993					; 000080e1H
	push	0
	mov	edi, esp
	mov	ecx, DWORD PTR _imageBitmap$63047[ebp]
	push	ecx
	call	DWORD PTR __imp__FreeImage_GetHeight@4
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	edi, esp
	mov	edx, DWORD PTR _imageBitmap$63047[ebp]
	push	edx
	call	DWORD PTR __imp__FreeImage_GetWidth@4
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	push	6408					; 00001908H
	push	0
	mov	eax, DWORD PTR _i$63013[ebp]
	mov	ecx, DWORD PTR _targets$[ebp+eax*4]
	push	ecx
	call	DWORD PTR __imp__glTexImage2D@36
	cmp	esi, esp
	call	__RTC_CheckEsp

; 218  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _texName$63017[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN2@LoadCubeMa
$LN1@LoadCubeMa:

; 219  : 
; 220  : 	// Set the cube map settings
; 221  :     glTexParameterf(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	mov	esi, esp
	push	ecx
	fld	DWORD PTR __real@46180400
	fstp	DWORD PTR [esp]
	push	10240					; 00002800H
	push	34067					; 00008513H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 222  :     glTexParameterf(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	mov	esi, esp
	push	ecx
	fld	DWORD PTR __real@46180400
	fstp	DWORD PTR [esp]
	push	10241					; 00002801H
	push	34067					; 00008513H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 223  :     glTexParameterf(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);

	mov	esi, esp
	push	ecx
	fld	DWORD PTR __real@47012f00
	fstp	DWORD PTR [esp]
	push	10242					; 00002802H
	push	34067					; 00008513H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 224  :     glTexParameterf(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	mov	esi, esp
	push	ecx
	fld	DWORD PTR __real@47012f00
	fstp	DWORD PTR [esp]
	push	10243					; 00002803H
	push	34067					; 00008513H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 225  :     glTexParameterf(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

	mov	esi, esp
	push	ecx
	fld	DWORD PTR __real@47012f00
	fstp	DWORD PTR [esp]
	push	32882					; 00008072H
	push	34067					; 00008513H
	call	DWORD PTR __imp__glTexParameterf@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 226  : 
; 227  : 	m_Program.SetUniform("CubeMapTex", 0);

	push	0
	push	OFFSET ??_C@_0L@NDBPDCJF@CubeMapTex?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?SetUniform@GLSLProgram@@QAEXPBDH@Z	; GLSLProgram::SetUniform

; 228  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@LoadCubeMa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 480				; 000001e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@LoadCubeMa:
	DD	4
	DD	$LN14@LoadCubeMa
$LN14@LoadCubeMa:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN9@LoadCubeMa
	DD	-92					; ffffffa4H
	DD	24					; 00000018H
	DD	$LN10@LoadCubeMa
	DD	-124					; ffffff84H
	DD	24					; 00000018H
	DD	$LN11@LoadCubeMa
	DD	-176					; ffffff50H
	DD	32					; 00000020H
	DD	$LN12@LoadCubeMa
$LN12@LoadCubeMa:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN11@LoadCubeMa:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN10@LoadCubeMa:
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN9@LoadCubeMa:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadCubeMap@EnvironmentMap@@AAEXXZ$0:
	lea	ecx, DWORD PTR $T63018[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadCubeMap@EnvironmentMap@@AAEXXZ$1:
	lea	ecx, DWORD PTR $T63045[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadCubeMap@EnvironmentMap@@AAEXXZ$2:
	lea	ecx, DWORD PTR _texName$63017[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?LoadCubeMap@EnvironmentMap@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-484]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadCubeMap@EnvironmentMap@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadCubeMap@EnvironmentMap@@AAEXXZ ENDP		; EnvironmentMap::LoadCubeMap
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T70920 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 592  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T70920[ebp], esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 593  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 594  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 595  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 752  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 753  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 754  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1495 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1497 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	??_C@_1IO@GEGAMENF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
;	COMDAT ??_C@_1IO@GEGAMENF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@GEGAMENF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '0', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 928  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 929  : 		_DEBUG_POINTER(_Ptr);

	push	929					; 000003a1H
	push	OFFSET ??_C@_1IO@GEGAMENF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 930  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 931  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
EXTRN	_strlen:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 490  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 491  : 		return (_CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 492  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$64941 = -20					; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1987 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1988 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 1989 : 			;
; 1990 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 1991 : 			{	// copy any leftovers to small buffer and deallocate
; 1992 : 			_Elem *_Ptr = this->_Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$64941[ebp], ecx

; 1993 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 1994 : 				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$64941[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 1995 : 			this->_Alval.deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$64941[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$LN3@Tidy:

; 1996 : 			}
; 1997 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 1998 : 		_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1999 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 496  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 497  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 498  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2008 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2009 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2010 : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv82[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv82[ebp]

; 2011 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
EXTRN	__imp_??1_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_??0_Container_base12@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
$T70953 = -240						; size = 8
__Alproxy$ = -29					; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 466  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 467  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 468  : 			_Alproxy(_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>

; 469  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 470  : 		_Cons_val(_Alproxy, this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T70953[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
	add	esp, 12					; 0000000cH

; 471  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@String_val
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN7@String_val:
	DD	1
	DD	$LN6@String_val
$LN6@String_val:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN4@String_val
$LN4@String_val:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z$0:
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 65   : 		{	// construct from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 66   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>
EXTRN	__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Alproxy$ = -29					; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 475  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 476  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 477  : 			_Alproxy(_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>

; 478  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 479  : 		_Dest_val(_Alproxy, this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>
	add	esp, 8

; 480  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 481  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 482  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@String_val@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@String_val@2:
	DD	1
	DD	$LN6@String_val@2
$LN6@String_val@2:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN4@String_val@2
$LN4@String_val@2:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 910  : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 911  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 912  : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN3@assign

; 913  : 			_DEBUG_POINTER(_Ptr);

	push	913					; 00000391H
	push	OFFSET ??_C@_1IO@GEGAMENF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN3@assign:

; 914  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 915  : 
; 916  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 917  : 			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN4@assign
$LN2@assign:

; 918  : 
; 919  : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 920  : 			{	// make room and assign new stuff
; 921  : 			_Traits::copy(_Myptr(), _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 922  : 			_Eos(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 923  : 			}
; 924  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN4@assign:

; 925  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T70986 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1952 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1953 : 		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T70986[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T70986[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 1954 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 526  : 		{	// assign an element

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 527  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 528  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2002 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2003 : 		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr
; 2004 : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN4@Myptr@2
$LN3@Myptr@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv82[ebp], eax
$LN4@Myptr@2:
	mov	eax, DWORD PTR tv82[ebp]

; 2005 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 183  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 183  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
	add	esp, 8

; 188  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 892  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 893  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign@2

; 894  : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign@2:

; 895  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 896  : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign@2

; 897  : 			_Num = _Count;	// trim _Num to size

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
$LN4@assign@2:

; 898  : 
; 899  : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign@2

; 900  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign@2
$LN3@assign@2:

; 901  : 		else if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign@2

; 902  : 			{	// make room and assign new stuff
; 903  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 904  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign@2:

; 905  : 			}
; 906  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign@2:

; 907  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1510 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1511 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1512 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2019 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2020 : 		_Xout_of_range("invalid string position");

	mov	esi, esp
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xran:

; 2021 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv129 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1958 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1959 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 1960 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 1961 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 1962 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 1963 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	eax, BYTE PTR __Trim$[ebp]
	test	eax, eax
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 1964 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1965 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 1966 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 1967 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 1968 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax
$LN8@Grow:

; 1969 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1972 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1973 : 		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 1974 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 1975 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 1976 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 1977 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2014 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2015 : 		_Xlength_error("string too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 2016 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$66597 = -20					; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1108 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN3@erase

; 1110 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN3@erase:

; 1111 : 		if (this->_Mysize - _Off < _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN2@erase

; 1112 : 			_Count = this->_Mysize - _Off;	// trim _Count

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN2@erase:

; 1113 : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@erase

; 1114 : 			{	// move elements down
; 1115 : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 1116 : 				this->_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1117 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$66597[ebp], ecx

; 1118 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$66597[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@erase:

; 1119 : 			}
; 1120 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN5@erase:

; 1121 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
EXTRN	__imp__memmove:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 516  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 517  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 518  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1515 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1516 : 		size_type _Num = this->_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1517 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv73[ebp], eax
$LN4@max_size:
	mov	eax, DWORD PTR tv73[ebp]

; 1518 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv185 = -248						; size = 4
tv184 = -248						; size = 4
__Ptr$ = -48						; size = 4
__Newres$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1918 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1919 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 1920 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 1921 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 1922 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 1923 : 			;
; 1924 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $LN5@Copy

; 1925 : 			_Newres = this->_Myres
; 1926 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1927 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 1928 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 1929 : 
; 1930 : 		_Elem *_Ptr;
; 1931 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1932 : 			_Ptr = this->_Alval.allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv184[ebp], eax
	mov	ecx, DWORD PTR tv184[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 1933 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1934 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 1935 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1936 : 				_Ptr = this->_Alval.allocate(_Newres + 1);

	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv185[ebp], eax
	mov	ecx, DWORD PTR tv185[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 1937 : 			_CATCH_ALL
; 1938 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1939 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1940 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	eax, __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 1941 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	eax, __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 1942 : 
; 1943 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 1944 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 1945 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1946 : 		this->_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1947 : 		this->_Myres = _Newres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 1948 : 		_Eos(_Oldlen);

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 1949 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 188  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -220						; size = 4
__Count$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 217  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 219  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 220  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec2.inl
_TEXT	ENDS
;	COMDAT ??0?$tvec2@M@detail@glm@@QAE@ABM0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
??0?$tvec2@M@detail@glm@@QAE@ABM0@Z PROC		; glm::detail::tvec2<float>::tvec2<float>, COMDAT
; _this$ = ecx

; 108  : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s1$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s2$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$tvec2@M@detail@glm@@QAE@ABM0@Z ENDP		; glm::detail::tvec2<float>::tvec2<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tvec2@M@detail@glm@@QAE@ABM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_s$ = 8							; size = 4
??0?$tvec2@M@detail@glm@@QAE@ABM@Z PROC			; glm::detail::tvec2<float>::tvec2<float>, COMDAT
; _this$ = ecx

; 98   : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$tvec2@M@detail@glm@@QAE@ABM@Z ENDP			; glm::detail::tvec2<float>::tvec2<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tvec2@M@detail@glm@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$tvec2@M@detail@glm@@QAE@XZ PROC			; glm::detail::tvec2<float>::tvec2<float>, COMDAT
; _this$ = ecx

; 70   : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$tvec2@M@detail@glm@@QAE@XZ ENDP			; glm::detail::tvec2<float>::tvec2<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??4?$tvec2@M@detail@glm@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
??4?$tvec2@M@detail@glm@@QAEAAU012@ABU012@@Z PROC	; glm::detail::tvec2<float>::operator=, COMDAT
; _this$ = ecx

; 187  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 		this->x = v.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 189  : 		this->y = v.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]

; 190  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 191  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$tvec2@M@detail@glm@@QAEAAU012@ABU012@@Z ENDP	; glm::detail::tvec2<float>::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec3.inl
_TEXT	ENDS
;	COMDAT ??0?$tvec3@M@detail@glm@@QAE@ABM00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_s0$ = 8						; size = 4
_s1$ = 12						; size = 4
_s2$ = 16						; size = 4
??0?$tvec3@M@detail@glm@@QAE@ABM00@Z PROC		; glm::detail::tvec3<float>::tvec3<float>, COMDAT
; _this$ = ecx

; 113  : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s0$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s1$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s2$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$tvec3@M@detail@glm@@QAE@ABM00@Z ENDP		; glm::detail::tvec3<float>::tvec3<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tvec3@M@detail@glm@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
??0?$tvec3@M@detail@glm@@QAE@ABU012@@Z PROC		; glm::detail::tvec3<float>::tvec3<float>, COMDAT
; _this$ = ecx

; 88   : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$tvec3@M@detail@glm@@QAE@ABU012@@Z ENDP		; glm::detail::tvec3<float>::tvec3<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tvec3@M@detail@glm@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$tvec3@M@detail@glm@@QAE@XZ PROC			; glm::detail::tvec3<float>::tvec3<float>, COMDAT
; _this$ = ecx

; 71   : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$tvec3@M@detail@glm@@QAE@XZ ENDP			; glm::detail::tvec3<float>::tvec3<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z PROC	; glm::detail::tvec3<float>::operator=, COMDAT
; _this$ = ecx

; 236  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 		this->x = v.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 238  : 		this->y = v.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]

; 239  : 		this->z = v.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+8]

; 240  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 241  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ENDP	; glm::detail::tvec3<float>::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec4.inl
_TEXT	ENDS
;	COMDAT ??0?$tvec4@M@detail@glm@@QAE@ABM000@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_s3$ = 16						; size = 4
_s4$ = 20						; size = 4
??0?$tvec4@M@detail@glm@@QAE@ABM000@Z PROC		; glm::detail::tvec4<float>::tvec4<float>, COMDAT
; _this$ = ecx

; 118  : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s1$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s2$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s3$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _s4$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0?$tvec4@M@detail@glm@@QAE@ABM000@Z ENDP		; glm::detail::tvec4<float>::tvec4<float>
_TEXT	ENDS
PUBLIC	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z	; glm::detail::tvec4<float>::operator=
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0?$tvec4@M@detail@glm@@QAE@XZ			; glm::detail::tvec4<float>::tvec4<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_mat4x4.inl
;	COMDAT ??0?$tmat4x4@M@detail@glm@@QAE@ABM@Z
_TEXT	SEGMENT
$T71068 = -308						; size = 16
$T71069 = -284						; size = 16
$T71070 = -260						; size = 16
$T71071 = -236						; size = 16
_Zero$ = -20						; size = 4
_this$ = -8						; size = 4
_s$ = 8							; size = 4
??0?$tmat4x4@M@detail@glm@@QAE@ABM@Z PROC		; glm::detail::tmat4x4<float>::tmat4x4<float>, COMDAT
; _this$ = ecx

; 113  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-312]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0?$tvec4@M@detail@glm@@QAE@XZ	; glm::detail::tvec4<float>::tvec4<float>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 114  : 		value_type const Zero(0);

	fldz
	fstp	DWORD PTR _Zero$[ebp]

; 115  :         this->value[0] = col_type(s, Zero, Zero, Zero);

	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71068[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 116  :         this->value[1] = col_type(Zero, s, Zero, Zero);

	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71069[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 117  :         this->value[2] = col_type(Zero, Zero, s, Zero);

	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71070[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 118  :         this->value[3] = col_type(Zero, Zero, Zero, s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71071[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 119  :     }

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@tmat4x4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 312				; 00000138H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN5@tmat4x4:
	DD	1
	DD	$LN4@tmat4x4
$LN4@tmat4x4:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@tmat4x4
$LN3@tmat4x4:
	DB	90					; 0000005aH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
??0?$tmat4x4@M@detail@glm@@QAE@ABM@Z ENDP		; glm::detail::tmat4x4<float>::tmat4x4<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_m$ = 8							; size = 4
??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z PROC		; glm::detail::tmat4x4<float>::tmat4x4<float>, COMDAT
; _this$ = ecx

; 94   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0?$tvec4@M@detail@glm@@QAE@XZ	; glm::detail::tvec4<float>::tvec4<float>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 95   :         this->value[0] = m.value[0];

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 96   :         this->value[1] = m.value[1];

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 97   :         this->value[2] = m.value[2];

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 98   :         this->value[3] = m.value[3];

	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 99   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z ENDP		; glm::detail::tmat4x4<float>::tmat4x4<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tmat4x4@M@detail@glm@@QAE@XZ
_TEXT	SEGMENT
$T71079 = -320						; size = 16
$T71080 = -296						; size = 16
$T71081 = -272						; size = 16
$T71082 = -248						; size = 16
_One$ = -32						; size = 4
_Zero$ = -20						; size = 4
_this$ = -8						; size = 4
??0?$tmat4x4@M@detail@glm@@QAE@XZ PROC			; glm::detail::tmat4x4<float>::tmat4x4<float>, COMDAT
; _this$ = ecx

; 80   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0?$tvec4@M@detail@glm@@QAE@XZ	; glm::detail::tvec4<float>::tvec4<float>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 81   : 		value_type Zero(0);

	fldz
	fstp	DWORD PTR _Zero$[ebp]

; 82   : 		value_type One(1);

	fld1
	fstp	DWORD PTR _One$[ebp]

; 83   :         this->value[0] = col_type(One, Zero, Zero, Zero);

	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _One$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71079[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 84   :         this->value[1] = col_type(Zero, One, Zero, Zero);

	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _One$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71080[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 85   :         this->value[2] = col_type(Zero, Zero, One, Zero);

	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _One$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71081[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 86   :         this->value[3] = col_type(Zero, Zero, Zero, One);

	lea	eax, DWORD PTR _One$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71082[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 87   :     }

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@tmat4x4@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@tmat4x4@2:
	DD	2
	DD	$LN5@tmat4x4@2
$LN5@tmat4x4@2:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@tmat4x4@2
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN4@tmat4x4@2
$LN4@tmat4x4@2:
	DB	79					; 0000004fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
$LN3@tmat4x4@2:
	DB	90					; 0000005aH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
??0?$tmat4x4@M@detail@glm@@QAE@XZ ENDP			; glm::detail::tmat4x4<float>::tmat4x4<float>
_TEXT	ENDS
PUBLIC	??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FO@LCBJDNCK@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@ ; `string'
PUBLIC	?length@?$tmat4x4@M@detail@glm@@QBEIXZ		; glm::detail::tmat4x4<float>::length
EXTRN	__imp___wassert:PROC
;	COMDAT ??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'i'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g'
	DB	00H, 't', 00H, 'h', 00H, '(', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@LCBJDNCK@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
CONST	SEGMENT
??_C@_1FO@LCBJDNCK@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'g', 00H, 'l', 00H, '\', 00H, 'g', 00H, 'l', 00H, 'm', 00H, '-'
	DB	00H, '0', 00H, '.', 00H, '9', 00H, '.', 00H, '3', 00H, '.', 00H
	DB	'1', 00H, '\', 00H, 'g', 00H, 'l', 00H, 'm', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'r', 00H, 'e', 00H, '\', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 't', 00H, '4'
	DB	00H, 'x', 00H, '4', 00H, '.', 00H, 'i', 00H, 'n', 00H, 'l', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z PROC	; glm::detail::tmat4x4<float>::operator[], COMDAT
; _this$ = ecx

; 59   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 		assert(i < this->length());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?length@?$tmat4x4@M@detail@glm@@QBEIXZ	; glm::detail::tmat4x4<float>::length
	cmp	DWORD PTR _i$[ebp], eax
	jb	SHORT $LN3@operator
	mov	esi, esp
	push	60					; 0000003cH
	push	OFFSET ??_C@_1FO@LCBJDNCK@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
	push	OFFSET ??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:

; 61   : 		return this->value[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]

; 62   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ENDP	; glm::detail::tmat4x4<float>::operator[]
_TEXT	ENDS
PUBLIC	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_m$ = 8							; size = 4
??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z PROC	; glm::detail::tmat4x4<float>::operator=, COMDAT
; _this$ = ecx

; 349  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  :         //memcpy could be faster
; 351  :         //memcpy(&this->value, &m.value, 16 * sizeof(valType));
; 352  :         this->value[0] = m[0];

	push	0
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 353  :         this->value[1] = m[1];

	push	1
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 354  :         this->value[2] = m[2];

	push	2
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 355  :         this->value[3] = m[3];

	push	3
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 356  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 357  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$tmat4x4@M@detail@glm@@QAEAAU012@ABU012@@Z ENDP	; glm::detail::tmat4x4<float>::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_mat3x3.inl
_TEXT	ENDS
;	COMDAT ??0?$tmat3x3@M@detail@glm@@QAE@ABU?$tvec3@M@12@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??0?$tmat3x3@M@detail@glm@@QAE@ABU?$tvec3@M@12@00@Z PROC ; glm::detail::tmat3x3<float>::tmat3x3<float>, COMDAT
; _this$ = ecx

; 138  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0?$tvec3@M@detail@glm@@QAE@XZ	; glm::detail::tvec3<float>::tvec3<float>
	push	3
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 139  :         this->value[0] = v0;

	mov	eax, DWORD PTR _v0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec3<float>::operator=

; 140  :         this->value[1] = v1;

	mov	eax, DWORD PTR _v1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec3<float>::operator=

; 141  :         this->value[2] = v2;

	mov	eax, DWORD PTR _v2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec3<float>::operator=

; 142  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$tmat3x3@M@detail@glm@@QAE@ABU?$tvec3@M@12@00@Z ENDP ; glm::detail::tmat3x3<float>::tmat3x3<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_mat4x4.inl
_TEXT	ENDS
;	COMDAT ??$?0N@?$tmat4x4@M@detail@glm@@QAE@ABN@Z
_TEXT	SEGMENT
$T71096 = -356						; size = 16
$T71097 = -332						; size = 4
$T71098 = -320						; size = 16
$T71099 = -296						; size = 4
$T71100 = -284						; size = 16
$T71101 = -260						; size = 4
$T71102 = -248						; size = 16
$T71103 = -224						; size = 4
_Zero$ = -20						; size = 4
_this$ = -8						; size = 4
_s$ = 8							; size = 4
??$?0N@?$tmat4x4@M@detail@glm@@QAE@ABN@Z PROC		; glm::detail::tmat4x4<float>::tmat4x4<float><double>, COMDAT
; _this$ = ecx

; 172  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-360]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0?$tvec4@M@detail@glm@@QAE@XZ	; glm::detail::tvec4<float>::tvec4<float>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 173  : 		GLM_STATIC_ASSERT(detail::type<U>::is_float || std::numeric_limits<U>::is_integer, "*mat4x4 constructor only takes float and integer types");
; 174  : 
; 175  : 		value_type const Zero(0);

	fldz
	fstp	DWORD PTR _Zero$[ebp]

; 176  :         this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);

	mov	eax, DWORD PTR _s$[ebp]
	fld	QWORD PTR [eax]
	fstp	DWORD PTR $T71097[ebp]
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71097[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71096[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 177  :         this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);

	mov	eax, DWORD PTR _s$[ebp]
	fld	QWORD PTR [eax]
	fstp	DWORD PTR $T71099[ebp]
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR $T71099[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71098[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 178  :         this->value[2] = tvec4<T>(Zero, Zero, value_type(s), Zero);

	mov	eax, DWORD PTR _s$[ebp]
	fld	QWORD PTR [eax]
	fstp	DWORD PTR $T71101[ebp]
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71101[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71100[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 179  :         this->value[3] = tvec4<T>(Zero, Zero, Zero, value_type(s));

	mov	eax, DWORD PTR _s$[ebp]
	fld	QWORD PTR [eax]
	fstp	DWORD PTR $T71103[ebp]
	lea	ecx, DWORD PTR $T71103[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71102[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 180  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@tmat4x4@3
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 360				; 00000168H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN5@tmat4x4@3:
	DD	1
	DD	$LN4@tmat4x4@3
$LN4@tmat4x4@3:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@tmat4x4@3
$LN3@tmat4x4@3:
	DB	90					; 0000005aH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
??$?0N@?$tmat4x4@M@detail@glm@@QAE@ABN@Z ENDP		; glm::detail::tmat4x4<float>::tmat4x4<float><double>
_TEXT	ENDS
PUBLIC	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z	; glm::detail::operator+<float>
PUBLIC	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
PUBLIC	??A?$tvec4@M@detail@glm@@QAEAAMI@Z		; glm::detail::tvec4<float>::operator[]
PUBLIC	??A?$tvec3@M@detail@glm@@QAEAAMI@Z		; glm::detail::tvec3<float>::operator[]
PUBLIC	??0?$tmat4x4@M@detail@glm@@QAE@W4ctor@012@@Z	; glm::detail::tmat4x4<float>::tmat4x4<float>
PUBLIC	??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABMABU201@@Z ; glm::detail::operator*<float>
PUBLIC	??$sin@M@glm@@YAMABM@Z				; glm::sin<float>
PUBLIC	??$cos@M@glm@@YAMABM@Z				; glm::cos<float>
PUBLIC	??$radians@M@glm@@YAMABM@Z			; glm::radians<float>
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\gtc\matrix_transform.inl
;	COMDAT ??$rotate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABMABU?$tvec3@M@20@@Z
_TEXT	SEGMENT
tv650 = -804						; size = 8
tv645 = -804						; size = 8
tv640 = -804						; size = 8
tv632 = -804						; size = 8
tv627 = -804						; size = 8
tv622 = -804						; size = 8
tv653 = -796						; size = 8
tv648 = -796						; size = 8
tv643 = -796						; size = 8
tv638 = -796						; size = 8
tv635 = -796						; size = 8
tv630 = -796						; size = 8
tv625 = -796						; size = 8
tv620 = -796						; size = 8
tv617 = -796						; size = 8
$T71110 = -784						; size = 4
$T71111 = -772						; size = 16
$T71112 = -748						; size = 16
$T71113 = -724						; size = 16
$T71114 = -700						; size = 16
$T71115 = -676						; size = 16
$T71116 = -652						; size = 16
$T71117 = -628						; size = 16
$T71118 = -604						; size = 16
$T71119 = -580						; size = 16
$T71120 = -556						; size = 16
$T71121 = -532						; size = 16
$T71122 = -508						; size = 16
$T71123 = -484						; size = 16
$T71124 = -460						; size = 16
$T71125 = -436						; size = 16
_Result$ = -220						; size = 64
_Rotate$ = -148						; size = 64
_temp$ = -76						; size = 12
_axis$ = -56						; size = 12
_s$ = -36						; size = 4
_c$ = -24						; size = 4
_a$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
_angle$ = 16						; size = 4
_v$ = 20						; size = 4
??$rotate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABMABU?$tvec3@M@20@@Z PROC ; glm::rotate<float>, COMDAT

; 50   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 804				; 00000324H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-804]
	mov	ecx, 201				; 000000c9H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 51   : 		T a = radians(angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	??$radians@M@glm@@YAMABM@Z		; glm::radians<float>
	add	esp, 4
	fstp	DWORD PTR _a$[ebp]

; 52   : 		T c = cos(a);

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$cos@M@glm@@YAMABM@Z			; glm::cos<float>
	add	esp, 4
	fstp	DWORD PTR _c$[ebp]

; 53   : 		T s = sin(a);

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$sin@M@glm@@YAMABM@Z			; glm::sin<float>
	add	esp, 4
	fstp	DWORD PTR _s$[ebp]

; 54   : 
; 55   : 		detail::tvec3<T> axis = normalize(v);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	lea	ecx, DWORD PTR _axis$[ebp]
	push	ecx
	call	??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z ; glm::normalize<float>
	add	esp, 8

; 56   : 
; 57   : 		detail::tvec3<T> temp = (T(1) - c) * axis;

	fld	DWORD PTR _c$[ebp]
	fld1
	fsubrp	ST(1), ST(0)
	fstp	DWORD PTR $T71110[ebp]
	lea	eax, DWORD PTR _axis$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71110[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABMABU201@@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH

; 58   : 
; 59   : 		detail::tmat4x4<T> Rotate(detail::tmat4x4<T>::null);

	push	0
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@W4ctor@012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>

; 60   : 		Rotate[0][0] = c + temp[0] * axis[0];

	push	0
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	0
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR _c$[ebp]
	push	0
	push	0
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv617[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv617[ebp]
	fstp	DWORD PTR [eax]

; 61   : 		Rotate[0][1] = 0 + temp[0] * axis[1] + s * axis[2];

	push	0
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	1
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fldz
	faddp	ST(1), ST(0)
	push	2
	lea	ecx, DWORD PTR _axis$[ebp]
	fstp	QWORD PTR tv620[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	fadd	QWORD PTR tv620[ebp]
	push	1
	push	0
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv622[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv622[ebp]
	fstp	DWORD PTR [eax]

; 62   : 		Rotate[0][2] = 0 + temp[0] * axis[2] - s * axis[1];

	push	0
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	2
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fldz
	faddp	ST(1), ST(0)
	push	1
	lea	ecx, DWORD PTR _axis$[ebp]
	fstp	QWORD PTR tv625[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	fsubr	QWORD PTR tv625[ebp]
	push	2
	push	0
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv627[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv627[ebp]
	fstp	DWORD PTR [eax]

; 63   : 
; 64   : 		Rotate[1][0] = 0 + temp[1] * axis[0] - s * axis[2];

	push	1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	0
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fldz
	faddp	ST(1), ST(0)
	push	2
	lea	ecx, DWORD PTR _axis$[ebp]
	fstp	QWORD PTR tv630[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	fsubr	QWORD PTR tv630[ebp]
	push	0
	push	1
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv632[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv632[ebp]
	fstp	DWORD PTR [eax]

; 65   : 		Rotate[1][1] = c + temp[1] * axis[1];

	push	1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	1
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR _c$[ebp]
	push	1
	push	1
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv635[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv635[ebp]
	fstp	DWORD PTR [eax]

; 66   : 		Rotate[1][2] = 0 + temp[1] * axis[2] + s * axis[0];

	push	1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	2
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fldz
	faddp	ST(1), ST(0)
	push	0
	lea	ecx, DWORD PTR _axis$[ebp]
	fstp	QWORD PTR tv638[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	fadd	QWORD PTR tv638[ebp]
	push	2
	push	1
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv640[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv640[ebp]
	fstp	DWORD PTR [eax]

; 67   : 
; 68   : 		Rotate[2][0] = 0 + temp[2] * axis[0] + s * axis[1];

	push	2
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	0
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fldz
	faddp	ST(1), ST(0)
	push	1
	lea	ecx, DWORD PTR _axis$[ebp]
	fstp	QWORD PTR tv643[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	fadd	QWORD PTR tv643[ebp]
	push	0
	push	2
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv645[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv645[ebp]
	fstp	DWORD PTR [eax]

; 69   : 		Rotate[2][1] = 0 + temp[2] * axis[1] - s * axis[0];

	push	2
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	1
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fldz
	faddp	ST(1), ST(0)
	push	0
	lea	ecx, DWORD PTR _axis$[ebp]
	fstp	QWORD PTR tv648[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	fsubr	QWORD PTR tv648[ebp]
	push	1
	push	2
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv650[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv650[ebp]
	fstp	DWORD PTR [eax]

; 70   : 		Rotate[2][2] = c + temp[2] * axis[2];

	push	2
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	mov	esi, eax
	push	2
	lea	ecx, DWORD PTR _axis$[ebp]
	call	??A?$tvec3@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec3<float>::operator[]
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fadd	DWORD PTR _c$[ebp]
	push	2
	push	2
	lea	ecx, DWORD PTR _Rotate$[ebp]
	fstp	QWORD PTR tv653[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv653[ebp]
	fstp	DWORD PTR [eax]

; 71   : 
; 72   : 		detail::tmat4x4<T> Result(detail::tmat4x4<T>::null);

	push	0
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@W4ctor@012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>

; 73   : 		Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];

	push	2
	push	0
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	2
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR $T71111[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	push	0
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	1
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR $T71112[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	0
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	edx, DWORD PTR $T71113[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T71114[ebp]
	push	eax
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T71115[ebp]
	push	ecx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 74   : 		Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];

	push	2
	push	1
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	2
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR $T71116[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	push	1
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	1
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR $T71117[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	0
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	edx, DWORD PTR $T71118[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T71119[ebp]
	push	eax
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T71120[ebp]
	push	ecx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 75   : 		Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];

	push	2
	push	2
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	2
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR $T71121[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	1
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR $T71122[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	push	2
	lea	ecx, DWORD PTR _Rotate$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	push	0
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	edx, DWORD PTR $T71123[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T71124[ebp]
	push	eax
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T71125[ebp]
	push	ecx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	2
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 76   : 		Result[3] = m[3];

	push	3
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	push	3
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 77   : 		return Result;

	lea	eax, DWORD PTR _Result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 78   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@rotate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 804				; 00000324H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@rotate:
	DD	5
	DD	$LN8@rotate
$LN8@rotate:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN3@rotate
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN4@rotate
	DD	-76					; ffffffb4H
	DD	12					; 0000000cH
	DD	$LN5@rotate
	DD	-148					; ffffff6cH
	DD	64					; 00000040H
	DD	$LN6@rotate
	DD	-220					; ffffff24H
	DD	64					; 00000040H
	DD	$LN7@rotate
$LN7@rotate:
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN6@rotate:
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$LN5@rotate:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN4@rotate:
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	0
$LN3@rotate:
	DB	97					; 00000061H
	DB	0
??$rotate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABMABU?$tvec3@M@20@@Z ENDP ; glm::rotate<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec4.inl
_TEXT	ENDS
;	COMDAT ??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z
_TEXT	SEGMENT
$T71135 = -236						; size = 4
$T71136 = -224						; size = 4
$T71137 = -212						; size = 4
$T71138 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
_s$ = 16						; size = 4
??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z PROC	; glm::detail::operator*<float>, COMDAT

; 892  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 893  : 		return tvec4<T>(
; 894  : 			v.x * s,
; 895  : 			v.y * s,
; 896  : 			v.z * s,
; 897  : 			v.w * s);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _s$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR $T71135[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR $T71136[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _s$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR $T71137[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _s$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR $T71138[ebp]
	lea	edx, DWORD PTR $T71135[ebp]
	push	edx
	lea	eax, DWORD PTR $T71136[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71137[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71138[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 898  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ENDP	; glm::detail::operator*<float>
_TEXT	ENDS
PUBLIC	??$inversesqrt@M@glm@@YAMABM@Z			; glm::inversesqrt<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\func_geometric.inl
;	COMDAT ??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z
_TEXT	SEGMENT
$T71141 = -212						; size = 4
_sqr$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z PROC ; glm::normalize<float>, COMDAT

; 243  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 244  :         GLM_STATIC_ASSERT(detail::type<T>::is_float, "'normalize' only accept floating-point inputs");
; 245  : 
; 246  : 		typename detail::tvec3<T>::value_type sqr = x.x * x.x + x.y * x.y + x.z * x.z;

	mov	eax, DWORD PTR _x$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _x$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _x$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _x$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _sqr$[ebp]

; 247  : 	    return x * inversesqrt(sqr);

	lea	eax, DWORD PTR _sqr$[ebp]
	push	eax
	call	??$inversesqrt@M@glm@@YAMABM@Z		; glm::inversesqrt<float>
	add	esp, 4
	fstp	DWORD PTR $T71141[ebp]
	lea	ecx, DWORD PTR $T71141[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 248  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@normalize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@normalize:
	DD	1
	DD	$LN4@normalize
$LN4@normalize:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN3@normalize
$LN3@normalize:
	DB	115					; 00000073H
	DB	113					; 00000071H
	DB	114					; 00000072H
	DB	0
??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z ENDP ; glm::normalize<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec3.inl
_TEXT	ENDS
;	COMDAT ??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@0@Z
_TEXT	SEGMENT
$T71147 = -224						; size = 4
$T71148 = -212						; size = 4
$T71149 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@0@Z PROC	; glm::detail::operator-<float>, COMDAT

; 716  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 717  : 		return tvec3<T>(
; 718  : 			v1.x - T(v2.x),
; 719  : 			v1.y - T(v2.y),
; 720  : 			v1.z - T(v2.z));

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR $T71147[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR $T71148[ebp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR $T71149[ebp]
	lea	eax, DWORD PTR $T71147[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71148[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71149[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 721  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@0@Z ENDP	; glm::detail::operator-<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@ABM@Z
_TEXT	SEGMENT
$T71152 = -224						; size = 4
$T71153 = -212						; size = 4
$T71154 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
_s$ = 16						; size = 4
??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@ABM@Z PROC	; glm::detail::operator*<float>, COMDAT

; 730  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 731  : 		return tvec3<T>(
; 732  : 			v.x * T(s),
; 733  : 			v.y * T(s),
; 734  : 			v.z * T(s));

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _s$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR $T71152[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _s$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR $T71153[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _s$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR $T71154[ebp]
	lea	eax, DWORD PTR $T71152[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71153[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71154[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 735  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@ABM@Z ENDP	; glm::detail::operator*<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??$?YM@?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
??$?YM@?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z PROC	; glm::detail::tvec3<float>::operator+=<float>, COMDAT
; _this$ = ecx

; 275  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 		this->x += T(v.x);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _v$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 277  : 		this->y += T(v.y);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _v$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 278  : 		this->z += T(v.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 279  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 280  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?YM@?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ENDP	; glm::detail::tvec3<float>::operator+=<float>
_TEXT	ENDS
PUBLIC	??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@@Z	; glm::detail::operator-<float>
PUBLIC	??$?0H@?$tmat4x4@M@detail@glm@@QAE@ABH@Z	; glm::detail::tmat4x4<float>::tmat4x4<float><int>
PUBLIC	??$cross@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@0@Z ; glm::cross<float>
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\gtc\matrix_transform.inl
;	COMDAT ??$lookAt@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU?$tvec3@M@20@00@Z
_TEXT	SEGMENT
tv235 = -424						; size = 4
tv233 = -424						; size = 4
tv231 = -424						; size = 4
$T71160 = -416						; size = 12
$T71161 = -396						; size = 12
$T71162 = -376						; size = 12
$T71163 = -356						; size = 4
$T71164 = -344						; size = 12
_Result$ = -132						; size = 64
_s$ = -60						; size = 12
_u$ = -40						; size = 12
_f$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_eye$ = 12						; size = 4
_center$ = 16						; size = 4
_up$ = 20						; size = 4
??$lookAt@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU?$tvec3@M@20@00@Z PROC ; glm::lookAt<float>, COMDAT

; 389  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-424]
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 390  : 		detail::tvec3<T> f = normalize(center - eye);

	mov	eax, DWORD PTR _eye$[ebp]
	push	eax
	mov	ecx, DWORD PTR _center$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71160[ebp]
	push	edx
	call	??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@0@Z ; glm::detail::operator-<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR _f$[ebp]
	push	eax
	call	??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z ; glm::normalize<float>
	add	esp, 8

; 391  : 		detail::tvec3<T> u = normalize(up);

	mov	eax, DWORD PTR _up$[ebp]
	push	eax
	lea	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z ; glm::normalize<float>
	add	esp, 8

; 392  : 		detail::tvec3<T> s = normalize(cross(f, u));

	lea	eax, DWORD PTR _u$[ebp]
	push	eax
	lea	ecx, DWORD PTR _f$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71161[ebp]
	push	edx
	call	??$cross@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@0@Z ; glm::cross<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	??$normalize@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@@Z ; glm::normalize<float>
	add	esp, 8

; 393  : 		u = cross(s, f);

	lea	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71162[ebp]
	push	edx
	call	??$cross@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@0@Z ; glm::cross<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _u$[ebp]
	call	??4?$tvec3@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec3<float>::operator=

; 394  : 
; 395  : 		detail::tmat4x4<T> Result(1);

	mov	DWORD PTR $T71163[ebp], 1
	lea	eax, DWORD PTR $T71163[ebp]
	push	eax
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??$?0H@?$tmat4x4@M@detail@glm@@QAE@ABH@Z ; glm::detail::tmat4x4<float>::tmat4x4<float><int>

; 396  : 		Result[0][0] = s.x;

	push	0
	push	0
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [eax]

; 397  : 		Result[1][0] = s.y;

	push	0
	push	1
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR _s$[ebp+4]
	fstp	DWORD PTR [eax]

; 398  : 		Result[2][0] = s.z;

	push	0
	push	2
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR _s$[ebp+8]
	fstp	DWORD PTR [eax]

; 399  : 		Result[0][1] = u.x;

	push	1
	push	0
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR _u$[ebp]
	fstp	DWORD PTR [eax]

; 400  : 		Result[1][1] = u.y;

	push	1
	push	1
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR _u$[ebp+4]
	fstp	DWORD PTR [eax]

; 401  : 		Result[2][1] = u.z;

	push	1
	push	2
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR _u$[ebp+8]
	fstp	DWORD PTR [eax]

; 402  : 		Result[0][2] =-f.x;

	fld	DWORD PTR _f$[ebp]
	fchs
	push	2
	push	0
	lea	ecx, DWORD PTR _Result$[ebp]
	fstp	DWORD PTR tv231[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR tv231[ebp]
	fstp	DWORD PTR [eax]

; 403  : 		Result[1][2] =-f.y;

	fld	DWORD PTR _f$[ebp+4]
	fchs
	push	2
	push	1
	lea	ecx, DWORD PTR _Result$[ebp]
	fstp	DWORD PTR tv233[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR tv233[ebp]
	fstp	DWORD PTR [eax]

; 404  : 		Result[2][2] =-f.z;

	fld	DWORD PTR _f$[ebp+8]
	fchs
	push	2
	push	2
	lea	ecx, DWORD PTR _Result$[ebp]
	fstp	DWORD PTR tv235[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR tv235[ebp]
	fstp	DWORD PTR [eax]

; 405  : 	/*  Test this instead of translate3D
; 406  : 		Result[3][0] =-dot(s, eye);
; 407  : 		Result[3][1] =-dot(y, eye);
; 408  : 		Result[3][2] = dot(f, eye);
; 409  : 	*/  
; 410  : 		return translate(Result, -eye);

	mov	eax, DWORD PTR _eye$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71164[ebp]
	push	ecx
	call	??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@@Z ; glm::detail::operator-<float>
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _Result$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$translate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABU?$tvec3@M@20@@Z ; glm::translate<float>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 411  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@lookAt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@lookAt:
	DD	4
	DD	$LN7@lookAt
$LN7@lookAt:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN3@lookAt
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN4@lookAt
	DD	-60					; ffffffc4H
	DD	12					; 0000000cH
	DD	$LN5@lookAt
	DD	-132					; ffffff7cH
	DD	64					; 00000040H
	DD	$LN6@lookAt
$LN6@lookAt:
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN5@lookAt:
	DB	115					; 00000073H
	DB	0
$LN4@lookAt:
	DB	117					; 00000075H
	DB	0
$LN3@lookAt:
	DB	102					; 00000066H
	DB	0
??$lookAt@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU?$tvec3@M@20@00@Z ENDP ; glm::lookAt<float>
_TEXT	ENDS
PUBLIC	??A?$tvec4@M@detail@glm@@QBEABMI@Z		; glm::detail::tvec4<float>::operator[]
PUBLIC	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z		; glm::detail::tvec4<float>::tvec4<float>
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_mat4x4.inl
;	COMDAT ??$?DM@detail@glm@@YA?AU?$tmat4x4@M@01@ABU201@0@Z
_TEXT	SEGMENT
$T71174 = -1128						; size = 16
$T71175 = -1104						; size = 16
$T71176 = -1080						; size = 16
$T71177 = -1056						; size = 16
$T71178 = -1032						; size = 16
$T71179 = -1008						; size = 16
$T71180 = -984						; size = 16
$T71181 = -960						; size = 16
$T71182 = -936						; size = 16
$T71183 = -912						; size = 16
$T71184 = -888						; size = 16
$T71185 = -864						; size = 16
$T71186 = -840						; size = 16
$T71187 = -816						; size = 16
$T71188 = -792						; size = 16
$T71189 = -768						; size = 16
$T71190 = -744						; size = 16
$T71191 = -720						; size = 16
$T71192 = -696						; size = 16
$T71193 = -672						; size = 16
$T71194 = -648						; size = 16
$T71195 = -624						; size = 16
$T71196 = -600						; size = 16
$T71197 = -576						; size = 16
$T71198 = -552						; size = 16
$T71199 = -528						; size = 16
$T71200 = -504						; size = 16
$T71201 = -480						; size = 16
_Result$ = -264						; size = 64
_SrcB3$ = -192						; size = 16
_SrcB2$ = -168						; size = 16
_SrcB1$ = -144						; size = 16
_SrcB0$ = -120						; size = 16
_SrcA3$ = -96						; size = 16
_SrcA2$ = -72						; size = 16
_SrcA1$ = -48						; size = 16
_SrcA0$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_m1$ = 12						; size = 4
_m2$ = 16						; size = 4
??$?DM@detail@glm@@YA?AU?$tmat4x4@M@01@ABU201@0@Z PROC	; glm::detail::operator*<float>, COMDAT

; 762  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 1132				; 0000046cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1132]
	mov	ecx, 283				; 0000011bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 763  : 		typename tmat4x4<T>::col_type const SrcA0 = m1[0];

	push	0
	mov	ecx, DWORD PTR _m1$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcA0$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec4<float>::tvec4<float>

; 764  : 		typename tmat4x4<T>::col_type const SrcA1 = m1[1];

	push	1
	mov	ecx, DWORD PTR _m1$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcA1$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec4<float>::tvec4<float>

; 765  : 		typename tmat4x4<T>::col_type const SrcA2 = m1[2];

	push	2
	mov	ecx, DWORD PTR _m1$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcA2$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec4<float>::tvec4<float>

; 766  : 		typename tmat4x4<T>::col_type const SrcA3 = m1[3];

	push	3
	mov	ecx, DWORD PTR _m1$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcA3$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec4<float>::tvec4<float>

; 767  : 
; 768  : 		typename tmat4x4<T>::col_type const SrcB0 = m2[0];

	push	0
	mov	ecx, DWORD PTR _m2$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcB0$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec4<float>::tvec4<float>

; 769  : 		typename tmat4x4<T>::col_type const SrcB1 = m2[1];

	push	1
	mov	ecx, DWORD PTR _m2$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcB1$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec4<float>::tvec4<float>

; 770  : 		typename tmat4x4<T>::col_type const SrcB2 = m2[2];

	push	2
	mov	ecx, DWORD PTR _m2$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcB2$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec4<float>::tvec4<float>

; 771  : 		typename tmat4x4<T>::col_type const SrcB3 = m2[3];

	push	3
	mov	ecx, DWORD PTR _m2$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcB3$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z	; glm::detail::tvec4<float>::tvec4<float>

; 772  : 
; 773  :         tmat4x4<T> Result(tmat4x4<T>::null);

	push	0
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@W4ctor@012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>

; 774  : 		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];

	push	3
	lea	ecx, DWORD PTR _SrcB0$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR _SrcA3$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71174[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	2
	lea	ecx, DWORD PTR _SrcB0$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	edx, DWORD PTR _SrcA2$[ebp]
	push	edx
	lea	eax, DWORD PTR $T71175[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	lea	ecx, DWORD PTR _SrcB0$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcA1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71176[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	lea	ecx, DWORD PTR _SrcB0$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR _SrcA0$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71177[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T71178[ebp]
	push	edx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T71179[ebp]
	push	eax
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T71180[ebp]
	push	ecx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 775  : 		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];

	push	3
	lea	ecx, DWORD PTR _SrcB1$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR _SrcA3$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71181[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	2
	lea	ecx, DWORD PTR _SrcB1$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	edx, DWORD PTR _SrcA2$[ebp]
	push	edx
	lea	eax, DWORD PTR $T71182[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	lea	ecx, DWORD PTR _SrcB1$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcA1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71183[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	lea	ecx, DWORD PTR _SrcB1$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR _SrcA0$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71184[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T71185[ebp]
	push	edx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T71186[ebp]
	push	eax
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T71187[ebp]
	push	ecx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 776  : 		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];

	push	3
	lea	ecx, DWORD PTR _SrcB2$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR _SrcA3$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71188[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	2
	lea	ecx, DWORD PTR _SrcB2$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	edx, DWORD PTR _SrcA2$[ebp]
	push	edx
	lea	eax, DWORD PTR $T71189[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	lea	ecx, DWORD PTR _SrcB2$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcA1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71190[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	lea	ecx, DWORD PTR _SrcB2$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR _SrcA0$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71191[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T71192[ebp]
	push	edx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T71193[ebp]
	push	eax
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T71194[ebp]
	push	ecx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	2
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 777  : 		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];

	push	3
	lea	ecx, DWORD PTR _SrcB3$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR _SrcA3$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71195[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	2
	lea	ecx, DWORD PTR _SrcB3$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	edx, DWORD PTR _SrcA2$[ebp]
	push	edx
	lea	eax, DWORD PTR $T71196[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	lea	ecx, DWORD PTR _SrcB3$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR _SrcA1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71197[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	lea	ecx, DWORD PTR _SrcB3$[ebp]
	call	??A?$tvec4@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR _SrcA0$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71198[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T71199[ebp]
	push	edx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T71200[ebp]
	push	eax
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T71201[ebp]
	push	ecx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	3
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 778  :         return Result;

	lea	eax, DWORD PTR _Result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 779  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@operator@2
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1132				; 0000046cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@operator@2:
	DD	9
	DD	$LN12@operator@2
$LN12@operator@2:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN3@operator@2
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN4@operator@2
	DD	-72					; ffffffb8H
	DD	16					; 00000010H
	DD	$LN5@operator@2
	DD	-96					; ffffffa0H
	DD	16					; 00000010H
	DD	$LN6@operator@2
	DD	-120					; ffffff88H
	DD	16					; 00000010H
	DD	$LN7@operator@2
	DD	-144					; ffffff70H
	DD	16					; 00000010H
	DD	$LN8@operator@2
	DD	-168					; ffffff58H
	DD	16					; 00000010H
	DD	$LN9@operator@2
	DD	-192					; ffffff40H
	DD	16					; 00000010H
	DD	$LN10@operator@2
	DD	-264					; fffffef8H
	DD	64					; 00000040H
	DD	$LN11@operator@2
$LN11@operator@2:
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$LN10@operator@2:
	DB	83					; 00000053H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	51					; 00000033H
	DB	0
$LN9@operator@2:
	DB	83					; 00000053H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	50					; 00000032H
	DB	0
$LN8@operator@2:
	DB	83					; 00000053H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	49					; 00000031H
	DB	0
$LN7@operator@2:
	DB	83					; 00000053H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	48					; 00000030H
	DB	0
$LN6@operator@2:
	DB	83					; 00000053H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	51					; 00000033H
	DB	0
$LN5@operator@2:
	DB	83					; 00000053H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	50					; 00000032H
	DB	0
$LN4@operator@2:
	DB	83					; 00000053H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	49					; 00000031H
	DB	0
$LN3@operator@2:
	DB	83					; 00000053H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	48					; 00000030H
	DB	0
??$?DM@detail@glm@@YA?AU?$tmat4x4@M@01@ABU201@0@Z ENDP	; glm::detail::operator*<float>
_TEXT	ENDS
PUBLIC	??$tan@M@glm@@YAMABM@Z				; glm::tan<float>
PUBLIC	__real@4000000000000000
PUBLIC	__$ArrayPad$
;	COMDAT __real@4000000000000000
; File c:\opengl\glm-0.9.3.1\glm\gtc\matrix_transform.inl
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??$perspective@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABM000@Z
_TEXT	SEGMENT
tv259 = -372						; size = 8
tv257 = -372						; size = 4
tv254 = -372						; size = 8
tv251 = -372						; size = 8
tv233 = -368						; size = 4
$T71216 = -360						; size = 4
$T71217 = -348						; size = 4
$T71218 = -336						; size = 4
_Result$ = -132						; size = 64
_top$ = -60						; size = 4
_bottom$ = -48						; size = 4
_right$ = -36						; size = 4
_left$ = -24						; size = 4
_range$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_fovy$ = 12						; size = 4
_aspect$ = 16						; size = 4
_zNear$ = 20						; size = 4
_zFar$ = 24						; size = 4
??$perspective@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABM000@Z PROC ; glm::perspective<float>, COMDAT

; 230  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 93					; 0000005dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 231  : 		valType range = tan(radians(fovy / valType(2))) * zNear;	

	mov	eax, DWORD PTR _fovy$[ebp]
	fld	DWORD PTR [eax]
	fdiv	QWORD PTR __real@4000000000000000
	fstp	DWORD PTR $T71217[ebp]
	lea	ecx, DWORD PTR $T71217[ebp]
	push	ecx
	call	??$radians@M@glm@@YAMABM@Z		; glm::radians<float>
	add	esp, 4
	fstp	DWORD PTR $T71216[ebp]
	lea	edx, DWORD PTR $T71216[ebp]
	push	edx
	call	??$tan@M@glm@@YAMABM@Z			; glm::tan<float>
	add	esp, 4
	mov	eax, DWORD PTR _zNear$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR _range$[ebp]

; 232  : 		valType left = -range * aspect;

	fld	DWORD PTR _range$[ebp]
	fchs
	mov	eax, DWORD PTR _aspect$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR _left$[ebp]

; 233  : 		valType right = range * aspect;

	fld	DWORD PTR _range$[ebp]
	mov	eax, DWORD PTR _aspect$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR _right$[ebp]

; 234  : 		valType bottom = -range;

	fld	DWORD PTR _range$[ebp]
	fchs
	fstp	DWORD PTR _bottom$[ebp]

; 235  : 		valType top = range;

	fld	DWORD PTR _range$[ebp]
	fstp	DWORD PTR _top$[ebp]

; 236  : 
; 237  : 		detail::tmat4x4<valType> Result(valType(0));

	fldz
	fstp	DWORD PTR $T71218[ebp]
	lea	eax, DWORD PTR $T71218[ebp]
	push	eax
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@ABM@Z	; glm::detail::tmat4x4<float>::tmat4x4<float>

; 238  : 		Result[0][0] = (valType(2) * zNear) / (right - left);

	mov	eax, DWORD PTR _zNear$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4000000000000000
	fld	DWORD PTR _right$[ebp]
	fsub	DWORD PTR _left$[ebp]
	fdivp	ST(1), ST(0)
	push	0
	push	0
	lea	ecx, DWORD PTR _Result$[ebp]
	fstp	QWORD PTR tv251[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv251[ebp]
	fstp	DWORD PTR [eax]

; 239  : 		Result[1][1] = (valType(2) * zNear) / (top - bottom);

	mov	eax, DWORD PTR _zNear$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4000000000000000
	fld	DWORD PTR _top$[ebp]
	fsub	DWORD PTR _bottom$[ebp]
	fdivp	ST(1), ST(0)
	push	1
	push	1
	lea	ecx, DWORD PTR _Result$[ebp]
	fstp	QWORD PTR tv254[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv254[ebp]
	fstp	DWORD PTR [eax]

; 240  : 		Result[2][2] = - (zFar + zNear) / (zFar - zNear);

	mov	eax, DWORD PTR _zFar$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _zNear$[ebp]
	fadd	DWORD PTR [ecx]
	fchs
	mov	edx, DWORD PTR _zFar$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _zNear$[ebp]
	fsub	DWORD PTR [eax]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR tv233[ebp]
	fld	DWORD PTR tv233[ebp]
	push	2
	push	2
	lea	ecx, DWORD PTR _Result$[ebp]
	fstp	DWORD PTR tv257[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR tv257[ebp]
	fstp	DWORD PTR [eax]

; 241  : 		Result[2][3] = - valType(1);

	push	3
	push	2
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	DWORD PTR __real@bf800000
	fstp	DWORD PTR [eax]

; 242  : 		Result[3][2] = - (valType(2) * zFar * zNear) / (zFar - zNear);

	mov	eax, DWORD PTR _zFar$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4000000000000000
	mov	ecx, DWORD PTR _zNear$[ebp]
	fmul	DWORD PTR [ecx]
	fchs
	mov	edx, DWORD PTR _zFar$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _zNear$[ebp]
	fsub	DWORD PTR [eax]
	fdivp	ST(1), ST(0)
	push	2
	push	3
	lea	ecx, DWORD PTR _Result$[ebp]
	fstp	QWORD PTR tv259[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??A?$tvec4@M@detail@glm@@QAEAAMI@Z	; glm::detail::tvec4<float>::operator[]
	fld	QWORD PTR tv259[ebp]
	fstp	DWORD PTR [eax]

; 243  : 		return Result;

	lea	eax, DWORD PTR _Result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 244  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@perspectiv
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@perspectiv:
	DD	1
	DD	$LN4@perspectiv
$LN4@perspectiv:
	DD	-132					; ffffff7cH
	DD	64					; 00000040H
	DD	$LN3@perspectiv
$LN3@perspectiv:
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
??$perspective@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABM000@Z ENDP ; glm::perspective<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec3.inl
_TEXT	ENDS
;	COMDAT ??$?0M@?$tvec3@M@detail@glm@@QAE@ABU?$tvec4@M@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
??$?0M@?$tvec3@M@detail@glm@@QAE@ABU?$tvec4@M@12@@Z PROC ; glm::detail::tvec3<float>::tvec3<float><float>, COMDAT
; _this$ = ecx

; 226  : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0M@?$tvec3@M@detail@glm@@QAE@ABU?$tvec4@M@12@@Z ENDP ; glm::detail::tvec3<float>::tvec3<float><float>
_TEXT	ENDS
PUBLIC	??A?$tvec3@M@detail@glm@@QBEABMI@Z		; glm::detail::tvec3<float>::operator[]
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\gtc\matrix_transform.inl
;	COMDAT ??$translate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABU?$tvec3@M@20@@Z
_TEXT	SEGMENT
$T71229 = -408						; size = 16
$T71230 = -384						; size = 16
$T71231 = -360						; size = 16
$T71232 = -336						; size = 16
$T71233 = -312						; size = 16
$T71234 = -288						; size = 16
_Result$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
_v$ = 16						; size = 4
??$translate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABU?$tvec3@M@20@@Z PROC ; glm::translate<float>, COMDAT

; 37   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 412				; 0000019cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-412]
	mov	ecx, 103				; 00000067H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 38   : 		detail::tmat4x4<T> Result(m);

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>

; 39   : 		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];

	push	3
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	push	2
	mov	ecx, DWORD PTR _v$[ebp]
	call	??A?$tvec3@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec3<float>::operator[]
	push	eax
	push	2
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	eax, DWORD PTR $T71229[ebp]
	push	eax
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	1
	mov	ecx, DWORD PTR _v$[ebp]
	call	??A?$tvec3@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec3<float>::operator[]
	push	eax
	push	1
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	ecx, DWORD PTR $T71230[ebp]
	push	ecx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	0
	mov	ecx, DWORD PTR _v$[ebp]
	call	??A?$tvec3@M@detail@glm@@QBEABMI@Z	; glm::detail::tvec3<float>::operator[]
	push	eax
	push	0
	mov	ecx, DWORD PTR _m$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	push	eax
	lea	edx, DWORD PTR $T71231[ebp]
	push	edx
	call	??$?DM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@ABM@Z ; glm::detail::operator*<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T71232[ebp]
	push	eax
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T71233[ebp]
	push	ecx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T71234[ebp]
	push	edx
	call	??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ; glm::detail::operator+<float>
	add	esp, 12					; 0000000cH
	push	eax
	push	3
	lea	ecx, DWORD PTR _Result$[ebp]
	call	??A?$tmat4x4@M@detail@glm@@QAEAAU?$tvec4@M@12@I@Z ; glm::detail::tmat4x4<float>::operator[]
	mov	ecx, eax
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 40   : 		return Result;

	lea	eax, DWORD PTR _Result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tmat4x4@M@detail@glm@@QAE@ABU012@@Z ; glm::detail::tmat4x4<float>::tmat4x4<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 41   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@translate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 412				; 0000019cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@translate:
	DD	1
	DD	$LN4@translate
$LN4@translate:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN3@translate
$LN3@translate:
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
??$translate@M@glm@@YA?AU?$tmat4x4@M@detail@0@ABU120@ABU?$tvec3@M@20@@Z ENDP ; glm::translate<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec2.inl
_TEXT	ENDS
;	COMDAT ??$?GM@detail@glm@@YA?AU?$tvec2@M@01@ABU201@0@Z
_TEXT	SEGMENT
$T71240 = -212						; size = 4
$T71241 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??$?GM@detail@glm@@YA?AU?$tvec2@M@01@ABU201@0@Z PROC	; glm::detail::operator-<float>, COMDAT

; 623  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 624  : 		return tvec2<T>(
; 625  : 			v1.x - T(v2.x),
; 626  : 			v1.y - T(v2.y));

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR $T71240[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR $T71241[ebp]
	lea	ecx, DWORD PTR $T71240[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71241[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec2@M@detail@glm@@QAE@ABM0@Z	; glm::detail::tvec2<float>::tvec2<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 627  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?GM@detail@glm@@YA?AU?$tvec2@M@01@ABU201@0@Z ENDP	; glm::detail::operator-<float>
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\string
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T71245 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 146  : 	{	// return string + NTCS

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T71245[ebp], 0

; 147  : 	return (_STD move(_Left.append(_Right)));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	push	eax
	call	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T71245[ebp]
	or	ecx, 1
	mov	DWORD PTR $T71245[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 148  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T71249 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 702  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
	mov	ecx, esp
	mov	DWORD PTR $T71249[ebp], esp
	push	eax
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 703  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 704  : 		assign(_STD forward<_Myt>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 705  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator!=<char,char>
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
$T71259 = -221						; size = 1
$T71260 = -209						; size = 1
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 713  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 714  : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN6@assign@3

; 715  : 			;
; 716  : 		else if (get_allocator() != _Right.get_allocator()

	jmp	$LN5@assign@3
$LN6@assign@3:

; 717  : 			&& this->_BUF_SIZE <= _Right._Myres)

	lea	eax, DWORD PTR $T71259[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
	push	eax
	lea	ecx, DWORD PTR $T71260[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
	push	eax
	call	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z	; std::operator!=<char,char>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@assign@3
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN4@assign@3

; 718  : 			*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 719  : 		else

	jmp	SHORT $LN5@assign@3
$LN4@assign@3:

; 720  : 			{	// not same, clear this and steal from _Right
; 721  : 			_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 722  : 			if (_Right._Myres < this->_BUF_SIZE)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jae	SHORT $LN2@assign@3

; 723  : 				_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 724  : 					_Right._Mysize + 1);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 725  : 			else

	jmp	SHORT $LN1@assign@3
$LN2@assign@3:

; 726  : 				{	// copy pointer
; 727  : 				this->_Bx._Ptr = _Right._Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 728  : 				_Right._Bx._Ptr = 0;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN1@assign@3:

; 729  : 				}
; 730  : 			this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 731  : 			this->_Myres = _Right._Myres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 732  : 
; 733  : 			_Right._Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
$LN5@assign@3:

; 734  : 			}
; 735  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 736  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 762  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 763  : 		return (assign(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 764  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 1905 : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1906 : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1907 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 886  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		return (assign(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 888  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 79   : 	return ((_Ty&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 79   : 	return ((_Ty&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 689  : 	{	// test iterator for non-singularity, const pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 690  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 691  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 692  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 270  : 	{	// test for allocator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 271  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z	; std::operator==<char,char>
	add	esp, 8
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 272  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z ; std::allocator<std::_Container_proxy>::construct
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>, COMDAT

; 279  : 	{	// construct using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	mov	eax, DWORD PTR __Src$[ebp]
	push	eax
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Pdest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Alval$[ebp]
	call	?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z ; std::allocator<std::_Container_proxy>::construct

; 281  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z ; std::allocator<std::_Container_proxy>::destroy
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z PROC ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>, COMDAT

; 286  : 	{	// destroy using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 287  : 	_Alval.destroy(_Pdest);

	mov	eax, DWORD PTR __Pdest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alval$[ebp]
	call	?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z ; std::allocator<std::_Container_proxy>::destroy

; 288  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
$T71283 = -220						; size = 12
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 31   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN4@Allocate

; 34   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	push	0
	lea	ecx, DWORD PTR $T71283[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T71283[ebp]
	push	eax
	call	__CxxThrowException@8
$LN3@Allocate:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 40   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T71292 = -220						; size = 12
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 31   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 32   : 
; 33   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN4@Allocate@2

; 34   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate@2
$LN4@Allocate@2:

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate@2
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

	push	0
	lea	ecx, DWORD PTR $T71292[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T71292[ebp]
	push	eax
	call	__CxxThrowException@8
$LN3@Allocate@2:

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate@2:

; 40   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	esi, esp
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___t$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], eax
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 838  : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 839  : 		_DEBUG_POINTER(_Ptr);

	push	839					; 00000347H
	push	OFFSET ??_C@_1IO@GEGAMENF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 840  : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 841  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 817  : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 818  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 819  : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN4@append

; 820  : 			_DEBUG_POINTER(_Ptr);

	push	820					; 00000334H
	push	OFFSET ??_C@_1IO@GEGAMENF@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN4@append:

; 821  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 822  : 
; 823  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@append

; 824  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	jmp	SHORT $LN6@append
$LN3@append:

; 825  : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@append

; 826  : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append:

; 827  : 
; 828  : 		size_type _Num;
; 829  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@append
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@append

; 830  : 			{	// make room and append new stuff
; 831  : 			_Traits::copy(_Myptr() + this->_Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 832  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@append:

; 833  : 			}
; 834  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@append:

; 835  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 798  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 799  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN4@append@2

; 800  : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@append@2:

; 801  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 802  : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@append@2

; 803  : 			_Count = _Num;	// trim _Count to size

	mov	eax, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN3@append@2:

; 804  : 		if (npos - this->_Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN2@append@2

; 805  : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@append@2:

; 806  : 
; 807  : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@append@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@append@2

; 808  : 			{	// make room and append new stuff
; 809  : 			_Traits::copy(_Myptr() + this->_Mysize,
; 810  : 				_Right._Myptr() + _Roff, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 811  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@append@2:

; 812  : 			}
; 813  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@append@2:

; 814  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z$0
__ehfuncinfo$?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp /RTCsu /ZI
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T71306 = -236						; size = 4
$T71307 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z PROC ; std::allocator<std::_Container_proxy>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T71307[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T71307[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR $T71307[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T71307[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T71306[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 203  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T71307[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z ENDP ; std::allocator<std::_Container_proxy>::construct
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 56   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 57   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 58   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 61   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 62   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z ; std::_Destroy<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z PROC ; std::allocator<std::_Container_proxy>::destroy, COMDAT
; _this$ = ecx

; 212  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z ; std::_Destroy<std::_Container_proxy>
	add	esp, 4

; 214  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy
_TEXT	ENDS
PUBLIC	??_C@_1FK@IBGOADNM@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@ ; `string'
PUBLIC	?length@?$tvec3@M@detail@glm@@QBEIXZ		; glm::detail::tvec3<float>::length
;	COMDAT ??_C@_1FK@IBGOADNM@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec3.inl
CONST	SEGMENT
??_C@_1FK@IBGOADNM@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'g', 00H, 'l', 00H, '\', 00H, 'g', 00H, 'l', 00H, 'm', 00H, '-'
	DB	00H, '0', 00H, '.', 00H, '9', 00H, '.', 00H, '3', 00H, '.', 00H
	DB	'1', 00H, '\', 00H, 'g', 00H, 'l', 00H, 'm', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'r', 00H, 'e', 00H, '\', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, '3'
	DB	00H, '.', 00H, 'i', 00H, 'n', 00H, 'l', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??A?$tvec3@M@detail@glm@@QBEABMI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$tvec3@M@detail@glm@@QBEABMI@Z PROC			; glm::detail::tvec3<float>::operator[], COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 		assert(i < this->length());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?length@?$tvec3@M@detail@glm@@QBEIXZ	; glm::detail::tvec3<float>::length
	cmp	DWORD PTR _i$[ebp], eax
	jb	SHORT $LN3@operator@3
	mov	esi, esp
	push	59					; 0000003bH
	push	OFFSET ??_C@_1FK@IBGOADNM@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
	push	OFFSET ??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator@3:

; 60   : 		return (&x)[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 61   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$tvec3@M@detail@glm@@QBEABMI@Z ENDP			; glm::detail::tvec3<float>::operator[]
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??A?$tvec3@M@detail@glm@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$tvec3@M@detail@glm@@QAEAAMI@Z PROC			; glm::detail::tvec3<float>::operator[], COMDAT
; _this$ = ecx

; 47   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 		assert(i < this->length());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?length@?$tvec3@M@detail@glm@@QBEIXZ	; glm::detail::tvec3<float>::length
	cmp	DWORD PTR _i$[ebp], eax
	jb	SHORT $LN3@operator@4
	mov	esi, esp
	push	48					; 00000030H
	push	OFFSET ??_C@_1FK@IBGOADNM@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
	push	OFFSET ??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator@4:

; 49   : 		return (&x)[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 50   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$tvec3@M@detail@glm@@QAEAAMI@Z ENDP			; glm::detail::tvec3<float>::operator[]
_TEXT	ENDS
PUBLIC	??_C@_1FK@PFPGOKFD@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@ ; `string'
PUBLIC	?length@?$tvec4@M@detail@glm@@QBEIXZ		; glm::detail::tvec4<float>::length
;	COMDAT ??_C@_1FK@PFPGOKFD@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec4.inl
CONST	SEGMENT
??_C@_1FK@PFPGOKFD@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'g', 00H, 'l', 00H, '\', 00H, 'g', 00H, 'l', 00H, 'm', 00H, '-'
	DB	00H, '0', 00H, '.', 00H, '9', 00H, '.', 00H, '3', 00H, '.', 00H
	DB	'1', 00H, '\', 00H, 'g', 00H, 'l', 00H, 'm', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'r', 00H, 'e', 00H, '\', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, '4'
	DB	00H, '.', 00H, 'i', 00H, 'n', 00H, 'l', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??A?$tvec4@M@detail@glm@@QBEABMI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$tvec4@M@detail@glm@@QBEABMI@Z PROC			; glm::detail::tvec4<float>::operator[], COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 		assert(i < this->length());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?length@?$tvec4@M@detail@glm@@QBEIXZ	; glm::detail::tvec4<float>::length
	cmp	DWORD PTR _i$[ebp], eax
	jb	SHORT $LN3@operator@5
	mov	esi, esp
	push	59					; 0000003bH
	push	OFFSET ??_C@_1FK@PFPGOKFD@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
	push	OFFSET ??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator@5:

; 60   : 		return (&x)[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 61   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$tvec4@M@detail@glm@@QBEABMI@Z ENDP			; glm::detail::tvec4<float>::operator[]
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??A?$tvec4@M@detail@glm@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$tvec4@M@detail@glm@@QAEAAMI@Z PROC			; glm::detail::tvec4<float>::operator[], COMDAT
; _this$ = ecx

; 47   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 		assert(i < this->length());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?length@?$tvec4@M@detail@glm@@QBEIXZ	; glm::detail::tvec4<float>::length
	cmp	DWORD PTR _i$[ebp], eax
	jb	SHORT $LN3@operator@6
	mov	esi, esp
	push	48					; 00000030H
	push	OFFSET ??_C@_1FK@PFPGOKFD@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
	push	OFFSET ??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator@6:

; 49   : 		return (&x)[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 50   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$tvec4@M@detail@glm@@QAEAAMI@Z ENDP			; glm::detail::tvec4<float>::operator[]
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z PROC		; glm::detail::tvec4<float>::tvec4<float>, COMDAT
; _this$ = ecx

; 90   : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$tvec4@M@detail@glm@@QAE@ABU012@@Z ENDP		; glm::detail::tvec4<float>::tvec4<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tvec4@M@detail@glm@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$tvec4@M@detail@glm@@QAE@XZ PROC			; glm::detail::tvec4<float>::tvec4<float>, COMDAT
; _this$ = ecx

; 72   : 	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$tvec4@M@detail@glm@@QAE@XZ ENDP			; glm::detail::tvec4<float>::tvec4<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_v$ = 8							; size = 4
??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z PROC	; glm::detail::tvec4<float>::operator=, COMDAT
; _this$ = ecx

; 375  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 		this->x = v.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 377  : 		this->y = v.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+4]

; 378  : 		this->z = v.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+8]

; 379  : 		this->w = v.w;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]

; 380  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 381  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ENDP	; glm::detail::tvec4<float>::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_mat4x4.inl
_TEXT	ENDS
;	COMDAT ?length@?$tmat4x4@M@detail@glm@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?length@?$tmat4x4@M@detail@glm@@QBEIXZ PROC		; glm::detail::tmat4x4<float>::length, COMDAT
; _this$ = ecx

; 34   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   :         return 4;

	mov	eax, 4

; 36   :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$tmat4x4@M@detail@glm@@QBEIXZ ENDP		; glm::detail::tmat4x4<float>::length
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??0?$tmat4x4@M@detail@glm@@QAE@W4ctor@012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$tmat4x4@M@detail@glm@@QAE@W4ctor@012@@Z PROC	; glm::detail::tmat4x4<float>::tmat4x4<float>, COMDAT
; _this$ = ecx

; 106  :     {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0?$tvec4@M@detail@glm@@QAE@XZ	; glm::detail::tvec4<float>::tvec4<float>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$tmat4x4@M@detail@glm@@QAE@W4ctor@012@@Z ENDP	; glm::detail::tmat4x4<float>::tmat4x4<float>
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT ??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z PROC	; glm::detail::tmat4x4<float>::operator[], COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		assert(i < this->length());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?length@?$tmat4x4@M@detail@glm@@QBEIXZ	; glm::detail::tmat4x4<float>::length
	cmp	DWORD PTR _i$[ebp], eax
	jb	SHORT $LN3@operator@7
	mov	esi, esp
	push	71					; 00000047H
	push	OFFSET ??_C@_1FO@LCBJDNCK@?$AAc?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AAg?$AAl?$AA?2?$AAg?$AAl?$AAm?$AA?9?$AA0?$AA?4?$AA9?$AA?4?$AA3?$AA?4?$AA1?$AA?2?$AAg?$AAl?$AAm?$AA?2?$AAc?$AAo?$AAr?$AAe?$AA?2?$AAt@
	push	OFFSET ??_C@_1CG@KOFHLCJL@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator@7:

; 72   : 		return this->value[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]

; 73   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$tmat4x4@M@detail@glm@@QBEABU?$tvec4@M@12@I@Z ENDP	; glm::detail::tmat4x4<float>::operator[]
_TEXT	ENDS
PUBLIC	__real@4066800000000000
PUBLIC	__real@40490fdb
;	COMDAT __real@4066800000000000
; File c:\opengl\glm-0.9.3.1\glm\core\func_trigonometric.inl
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??$radians@M@glm@@YAMABM@Z
_TEXT	SEGMENT
tv73 = -208						; size = 4
_pi$ = -8						; size = 4
_degrees$ = 8						; size = 4
??$radians@M@glm@@YAMABM@Z PROC				; glm::radians<float>, COMDAT

; 39   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 40   : 		GLM_STATIC_ASSERT(detail::type<genType>::is_float, "'radians' only accept floating-point input");
; 41   : 
; 42   : 		genType const pi = genType(3.1415926535897932384626433832795);

	fld	DWORD PTR __real@40490fdb
	fstp	DWORD PTR _pi$[ebp]

; 43   : 		return degrees * (pi / genType(180));

	fld	DWORD PTR _pi$[ebp]
	fdiv	QWORD PTR __real@4066800000000000
	mov	eax, DWORD PTR _degrees$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]

; 44   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$radians@M@glm@@YAMABM@Z ENDP				; glm::radians<float>
_TEXT	ENDS
PUBLIC	?cos@@YAMM@Z					; cos
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??$cos@M@glm@@YAMABM@Z
_TEXT	SEGMENT
_angle$ = 8						; size = 4
??$cos@M@glm@@YAMABM@Z PROC				; glm::cos<float>, COMDAT

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 81   : 		GLM_STATIC_ASSERT(detail::type<genType>::is_float, "'cos' only accept floating-point input");
; 82   : 
; 83   : 		return ::std::cos(angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	call	?cos@@YAMM@Z				; cos
	add	esp, 4

; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$cos@M@glm@@YAMABM@Z ENDP				; glm::cos<float>
_TEXT	ENDS
PUBLIC	_cosf
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 512  :         {return (cosf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_cosf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
EXTRN	_cos:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _cosf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_cos
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
PUBLIC	?sin@@YAMM@Z					; sin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\func_trigonometric.inl
;	COMDAT ??$sin@M@glm@@YAMABM@Z
_TEXT	SEGMENT
_angle$ = 8						; size = 4
??$sin@M@glm@@YAMABM@Z PROC				; glm::sin<float>, COMDAT

; 69   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 70   : 		GLM_STATIC_ASSERT(detail::type<genType>::is_float, "'sin' only accept floating-point input");
; 71   : 
; 72   : 		return ::std::sin(angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	call	?sin@@YAMM@Z				; sin
	add	esp, 4

; 73   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$sin@M@glm@@YAMABM@Z ENDP				; glm::sin<float>
_TEXT	ENDS
PUBLIC	_sinf
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 538  :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sinf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
EXTRN	_sin:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _sinf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sin
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sinf	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec3.inl
_TEXT	ENDS
;	COMDAT ??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABMABU201@@Z
_TEXT	SEGMENT
$T71368 = -224						; size = 4
$T71369 = -212						; size = 4
$T71370 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
_v$ = 16						; size = 4
??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABMABU201@@Z PROC	; glm::detail::operator*<float>, COMDAT

; 743  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 744  : 		return tvec3<T>(
; 745  : 			T(s) * v.x,
; 746  : 			T(s) * v.y,
; 747  : 			T(s) * v.z);

	mov	eax, DWORD PTR _s$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _v$[ebp]
	fmul	DWORD PTR [ecx+8]
	fstp	DWORD PTR $T71368[ebp]
	mov	edx, DWORD PTR _s$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _v$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR $T71369[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR $T71370[ebp]
	lea	eax, DWORD PTR $T71368[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71369[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71370[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?DM@detail@glm@@YA?AU?$tvec3@M@01@ABMABU201@@Z ENDP	; glm::detail::operator*<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec4.inl
_TEXT	ENDS
;	COMDAT ??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z
_TEXT	SEGMENT
$T71373 = -236						; size = 4
$T71374 = -224						; size = 4
$T71375 = -212						; size = 4
$T71376 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z PROC	; glm::detail::operator+<float>, COMDAT

; 834  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 835  : 		return tvec4<T>(
; 836  : 			v1.x + v2.x,
; 837  : 			v1.y + v2.y,
; 838  : 			v1.z + v2.z,
; 839  : 			v1.w + v2.w);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR $T71373[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [eax+8]
	fstp	DWORD PTR $T71374[ebp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [edx+4]
	fstp	DWORD PTR $T71375[ebp]
	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR $T71376[ebp]
	lea	edx, DWORD PTR $T71373[ebp]
	push	edx
	lea	eax, DWORD PTR $T71374[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71375[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71376[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 840  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?HM@detail@glm@@YA?AU?$tvec4@M@01@ABU201@0@Z ENDP	; glm::detail::operator+<float>
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\func_exponential.inl
;	COMDAT ??$inversesqrt@M@glm@@YAMABM@Z
_TEXT	SEGMENT
tv76 = -196						; size = 4
_x$ = 8							; size = 4
??$inversesqrt@M@glm@@YAMABM@Z PROC			; glm::inversesqrt<float>, COMDAT

; 149  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 150  : 		GLM_STATIC_ASSERT(detail::type<genType>::is_float, "'inversesqrt' only accept floating-point input");
; 151  : 
; 152  :         return genType(1) / ::std::sqrt(x);

	mov	eax, DWORD PTR _x$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR tv76[ebp]
	fld	DWORD PTR tv76[ebp]

; 153  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$inversesqrt@M@glm@@YAMABM@Z ENDP			; glm::inversesqrt<float>
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\func_geometric.inl
_TEXT	ENDS
;	COMDAT ??$cross@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@0@Z
_TEXT	SEGMENT
$T71385 = -224						; size = 4
$T71386 = -212						; size = 4
$T71387 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
??$cross@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@0@Z PROC	; glm::cross<float>, COMDAT

; 204  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 205  : 		GLM_STATIC_ASSERT(detail::type<T>::is_float, "'cross' only accept floating-point inputs");
; 206  : 
; 207  :         return detail::tvec3<T>(
; 208  :             x.y * y.z - y.y * x.z,
; 209  :             x.z * y.x - y.z * x.x,
; 210  :             x.x * y.y - y.x * x.y);

	mov	eax, DWORD PTR _x$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _y$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _y$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _x$[ebp]
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T71385[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _y$[ebp]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _y$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _x$[ebp]
	fmul	DWORD PTR [ecx]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T71386[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _y$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _y$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _x$[ebp]
	fmul	DWORD PTR [edx+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T71387[ebp]
	lea	eax, DWORD PTR $T71385[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71386[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71387[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$cross@M@glm@@YA?AU?$tvec3@M@detail@0@ABU120@0@Z ENDP	; glm::cross<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_mat4x4.inl
_TEXT	ENDS
;	COMDAT ??$?0H@?$tmat4x4@M@detail@glm@@QAE@ABH@Z
_TEXT	SEGMENT
$T71390 = -356						; size = 16
$T71391 = -332						; size = 4
$T71392 = -320						; size = 16
$T71393 = -296						; size = 4
$T71394 = -284						; size = 16
$T71395 = -260						; size = 4
$T71396 = -248						; size = 16
$T71397 = -224						; size = 4
_Zero$ = -20						; size = 4
_this$ = -8						; size = 4
_s$ = 8							; size = 4
??$?0H@?$tmat4x4@M@detail@glm@@QAE@ABH@Z PROC		; glm::detail::tmat4x4<float>::tmat4x4<float><int>, COMDAT
; _this$ = ecx

; 172  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-360]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0?$tvec4@M@detail@glm@@QAE@XZ	; glm::detail::tvec4<float>::tvec4<float>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EPAX0@Z@Z

; 173  : 		GLM_STATIC_ASSERT(detail::type<U>::is_float || std::numeric_limits<U>::is_integer, "*mat4x4 constructor only takes float and integer types");
; 174  : 
; 175  : 		value_type const Zero(0);

	fldz
	fstp	DWORD PTR _Zero$[ebp]

; 176  :         this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);

	mov	eax, DWORD PTR _s$[ebp]
	fild	DWORD PTR [eax]
	fstp	DWORD PTR $T71391[ebp]
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71391[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71390[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 177  :         this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);

	mov	eax, DWORD PTR _s$[ebp]
	fild	DWORD PTR [eax]
	fstp	DWORD PTR $T71393[ebp]
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR $T71393[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71392[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 178  :         this->value[2] = tvec4<T>(Zero, Zero, value_type(s), Zero);

	mov	eax, DWORD PTR _s$[ebp]
	fild	DWORD PTR [eax]
	fstp	DWORD PTR $T71395[ebp]
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71395[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71394[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 179  :         this->value[3] = tvec4<T>(Zero, Zero, Zero, value_type(s));

	mov	eax, DWORD PTR _s$[ebp]
	fild	DWORD PTR [eax]
	fstp	DWORD PTR $T71397[ebp]
	lea	ecx, DWORD PTR $T71397[ebp]
	push	ecx
	lea	edx, DWORD PTR _Zero$[ebp]
	push	edx
	lea	eax, DWORD PTR _Zero$[ebp]
	push	eax
	lea	ecx, DWORD PTR _Zero$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71396[ebp]
	call	??0?$tvec4@M@detail@glm@@QAE@ABM000@Z	; glm::detail::tvec4<float>::tvec4<float>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4?$tvec4@M@detail@glm@@QAEAAU012@ABU012@@Z ; glm::detail::tvec4<float>::operator=

; 180  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@tmat4x4@4
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 360				; 00000168H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN5@tmat4x4@4:
	DD	1
	DD	$LN4@tmat4x4@4
$LN4@tmat4x4@4:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@tmat4x4@4
$LN3@tmat4x4@4:
	DB	90					; 0000005aH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
??$?0H@?$tmat4x4@M@detail@glm@@QAE@ABH@Z ENDP		; glm::detail::tmat4x4<float>::tmat4x4<float><int>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec3.inl
_TEXT	ENDS
;	COMDAT ??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@@Z
_TEXT	SEGMENT
$T71403 = -224						; size = 4
$T71404 = -212						; size = 4
$T71405 = -200						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@@Z PROC	; glm::detail::operator-<float>, COMDAT

; 809  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 810  : 		return tvec3<T>(
; 811  : 			-v.x, 
; 812  : 			-v.y, 
; 813  : 			-v.z);

	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	fstp	DWORD PTR $T71403[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	fstp	DWORD PTR $T71404[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx]
	fchs
	fstp	DWORD PTR $T71405[ebp]
	lea	eax, DWORD PTR $T71403[ebp]
	push	eax
	lea	ecx, DWORD PTR $T71404[ebp]
	push	ecx
	lea	edx, DWORD PTR $T71405[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tvec3@M@detail@glm@@QAE@ABM00@Z	; glm::detail::tvec3<float>::tvec3<float>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 814  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?GM@detail@glm@@YA?AU?$tvec3@M@01@ABU201@@Z ENDP	; glm::detail::operator-<float>
_TEXT	ENDS
PUBLIC	?tan@@YAMM@Z					; tan
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\func_trigonometric.inl
;	COMDAT ??$tan@M@glm@@YAMABM@Z
_TEXT	SEGMENT
_angle$ = 8						; size = 4
??$tan@M@glm@@YAMABM@Z PROC				; glm::tan<float>, COMDAT

; 94   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 95   : 		GLM_STATIC_ASSERT(detail::type<genType>::is_float, "'tan' only accept floating-point input");
; 96   : 
; 97   : 		return ::std::tan(angle);

	mov	eax, DWORD PTR _angle$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	call	?tan@@YAMM@Z				; tan
	add	esp, 4

; 98   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$tan@M@glm@@YAMABM@Z ENDP				; glm::tan<float>
_TEXT	ENDS
PUBLIC	_tanf
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?tan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?tan@@YAMM@Z PROC					; tan, COMDAT

; 544  :         {return (tanf(_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_tanf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?tan@@YAMM@Z ENDP					; tan
_TEXT	ENDS
EXTRN	_tan:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _tanf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 436  :         {return ((float)tan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_tan
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_tanf	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 262  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 263  : 	return (true);

	mov	al, 1

; 264  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 79   : 	return ((_Ty&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z PROC ; std::_Destroy<std::_Container_proxy>, COMDAT

; 62   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z ENDP ; std::_Destroy<std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec3.inl
_TEXT	ENDS
;	COMDAT ?length@?$tvec3@M@detail@glm@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?length@?$tvec3@M@detail@glm@@QBEIXZ PROC		; glm::detail::tvec3<float>::length, COMDAT
; _this$ = ecx

; 34   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return 3;

	mov	eax, 3

; 36   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$tvec3@M@detail@glm@@QBEIXZ ENDP		; glm::detail::tvec3<float>::length
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\opengl\glm-0.9.3.1\glm\core\type_vec4.inl
_TEXT	ENDS
;	COMDAT ?length@?$tvec4@M@detail@glm@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?length@?$tvec4@M@detail@glm@@QBEIXZ PROC		; glm::detail::tvec4<float>::length, COMDAT
; _this$ = ecx

; 34   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return 4;

	mov	eax, 4

; 36   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$tvec4@M@detail@glm@@QBEIXZ ENDP		; glm::detail::tvec4<float>::length
_TEXT	ENDS
END
